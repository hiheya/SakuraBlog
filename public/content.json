{"meta":{"title":"Rookie_l's Bolg","subtitle":null,"description":"与君共赴，万里征程。","author":"Rookie_l","url":""},"pages":[{"title":"archive","date":"2020-12-20T15:13:05.000Z","updated":"2022-08-23T16:00:37.652Z","comments":false,"path":"archive/index.html","permalink":"/archive/index.html","excerpt":"","text":"","keywords":"我所有的文档都在这了~"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2022-08-23T15:14:10.688Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2022-08-23T15:12:36.277Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2022-08-23T15:45:08.809Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[关于Rookie_l] 与&nbsp; Rookie_l&nbsp; （ 大揭秘 ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2022-08-23T15:35:58.250Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2022-08-23T16:06:32.203Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2022-08-25T15:11:51.559Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2021-11-09T14:13:18.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"music","date":"2022-08-20T15:14:28.000Z","updated":"2022-08-23T15:44:27.431Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"categories","date":"2018-12-12T14:14:16.000Z","updated":"2022-08-25T15:53:29.998Z","comments":true,"path":"categories/index.html","permalink":"/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"WP备份","slug":"WP备份","date":"2022-08-25T14:43:48.000Z","updated":"2022-08-25T15:09:36.478Z","comments":true,"path":"2022/08/25/wpbeifen/","link":"","permalink":"/2022/08/25/wpbeifen/","excerpt":"","text":"argon主题选项文本附加内容您当前正在 - %link% .页面，阅读由“%author%” 撰写的《%title%》 非常感谢您对我们的网站感兴趣并访问。在您使用本网站之前，请您仔细阅读本声明的所有条款。 版权声明： 1、本博客属个人所有，不涉及商业目的。 2、本博客内容均为本人编写，图片版权属于原作者，图片仅供大家欣赏和分享，切勿做为商业目的使用。如果侵害了您的合法权益，请您及时与我们，我们会在第一时间删除相关内容！ 3、本博客所有原创作品，包括文字、资料、图片、网页格式，转载时请标注作者与来源。非经允许，不得用于赢利目的。 4、本博客受中国知识产权、互联网法规和知识共享条例保护和保障，任何人不得进行旨在破坏或牟取私利的行为。 5、做新时代合格网民，弘扬互联网精神：开放、平等、 协作 、分享；共同构建文明、清朗的网络环境 6、本声明未涉及的问题参见国家有关法律法规，当本声明与国家法律法规冲突时，以国家法律法规为准。 7、当您阅读到这里的时候，即表明已阅读并接受了上述各项条款; 页脚内容&lt;p>&lt;b>Copyright 2022 Xiheya&lt;/b>, All Rights Reserved.&lt;/p> &lt;p>&lt;b>本站已&lt;del>稳定运行&lt;/b>&lt;/del>:&lt;span id=\"blog_running_days\" class=\"odometer\">&lt;/span> days , &lt;span id=\"blog_running_hours\" class=\"odometer\">&lt;/span> h , &lt;span id=\"blog_running_mins\" class=\"odometer\">&lt;/span> m , &lt;span id=\"blog_running_secs\" class=\"odometer\">&lt;/span> s&lt;/p> &lt;script no-pjax> var blog_running_days=document.getElementById(\"blog_running_days\"); var blog_running_hours=document.getElementById(\"blog_running_hours\"); var blog_running_mins=document.getElementById(\"blog_running_mins\"); var blog_running_secs=document.getElementById(\"blog_running_secs\"); function refresh_blog_running_time(){ var time = new Date() - new Date(2021, 10, 16, 5, 20, 0); var d=parseInt(time/24/60/60/1000); var h=parseInt(time%(24*60*60*1000)/60/60/1000); var m=parseInt(time%(60*60*1000)/60/1000); var s=parseInt(time%(60*1000)/1000); blog_running_days.innerHTML=d; blog_running_hours.innerHTML=h; blog_running_mins.innerHTML=m; blog_running_secs.innerHTML=s; } refresh_blog_running_time(); if (typeof(bottomTimeIntervalHasSet) == \"undefined\"){ var bottomTimeIntervalHasSet = true; setInterval(function(){refresh_blog_running_time();},500); } &lt;/script> 主题颜色#9a92b9 banner副标题：记录我的日常生活&amp;学习笔记 页面背景：https://img30.360buyimg.com/pop/jfs/t1/128389/8/25215/1839159/622820daEea902288/cdc24c6bd0f9c593.jpg 左侧栏左侧栏标题 与君共赴，万里征程。 左侧栏子标题（格言） --hitokoto-- 左侧栏作者名称 未可知. 左侧栏作者头像地址 https://img30.360buyimg.com/pop/jfs/t1/131661/35/25896/114014/62246b27Ec3b050cb/373a661d7463f92a.png 留言板与友链留言板内容：留言规则 留言者应遵守国家相关法律法规，不得发表违反中华人民共和国宪法、法律和有关政策的言论; 留言者承担因留言行为而直接或间接引起的法律责任; 本博客拥有发布、编辑、删除公众留言的权利，凡不符合本须知规定的留言将予以删除; 如果你有任何问题或是要求，可以在这里给我发送消息; 如在本博客目留言，即表明已阅读并接受了上述各项条款; 友链内容[friendlinks style=&quot;1-square&quot; sort=&quot;rand&quot;/] //方形头像，随机排序 友链格式 : 博客名称：Rookie_L’s Blog 描述：一个小菜鸡自建的blog，主要用于记录自己的生活日常&amp;学习笔记 站点：https://solstice23.top Avatar (头像)：https://solstice23.top/friendlink_image/avatar/ 菜单栏顶部导航标签&lt;i class=\"fa fa-home\" aria-hidden=\"true\">&lt;/i> 首页 &lt;i class=\"fa fa-comments\" aria-hidden=\"true\">&lt;/i> 留言板 &lt;i class=\"fa fa-link\" aria-hidden=\"true\">&lt;/i> 友情链接 &lt;i class=\"fa fa-clock-o\" aria-hidden=\"true\">&lt;/i> 归档 &lt;i class=\"fa fa-star\" aria-hidden=\"true\">&lt;/i>分类 &lt;i class=\"fa fa-caret-down\" style=\"margin-left:3px;\">&lt;/i> &lt;i class=\"fa fa-tags\" aria-hidden=\"true\">&lt;/i> 标签&lt;i class=\"fa fa-caret-down\" style=\"margin-left:3px;\">&lt;/i> 左侧栏菜单导航url：https://docs.oracle.com/javase/8/docs/api/ 标签：&lt;i class=\"fa fa-question-circle\" aria-hidden=\"true\">&lt;/i> API帮助文档 url：https://leetcode-cn.com/ 标签：&lt;i class=\"fa fa-code\" aria-hidden=\"true\">&lt;/i> LeetCode url：https://codetop.cc/home 标签：&lt;i class=\"fa fa-codepen\" aria-hidden=\"true\">&lt;/i> CodeTop url：https://github.com/ 标签：&lt;i class=\"fa fa-github-alt\" aria-hidden=\"true\">&lt;/i> GayHub url：https://www.programmercarl.com/ 标签：&lt;i class=\"fa fa-eye\" aria-hidden=\"true\">&lt;/i> 代码随想录 url：https://www.runoob.com/ 标签：&lt;i class=\"fa fa-child\" aria-hidden=\"true\">&lt;/i> 笨鸟先飞 左侧个人链接：1. URL：https://cloud.icu007.work/ 标签： &lt;i class=\"fa fa-cloud\" aria-hidden=\"true\">&lt;/i> 可道云 2. URL：mailto:rookie_l@icu007.work 标签：&lt;i class=\"fa fa-envelope\" aria-hidden=\"true\">&lt;/i> 联系我 3. URL：https://alist.icu007.work/ 标签：&lt;i class=\"fa fa-hdd-o\" aria-hidden=\"true\">&lt;/i> 分享盘 4. URL：https://drive.icu007.work/ 标签： &lt;i class=\"fa fa-download\" aria-hidden=\"true\">&lt;/i> 下载盘 5. URL：https://baidu.icu007.work 标签： &lt;i class=\"fa fa-question\" aria-hidden=\"true\">&lt;/i> 百度一下 6. URL： http://hiheya.github.io 标签： &lt;i class=\"fa fa-user\" aria-hidden=\"true\">&lt;/i> 子站","categories":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}],"tags":[{"name":"WP","slug":"WP","permalink":"/tags/WP/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}]},{"title":"记一次office无法联网解决方法","slug":"记一次office无法联网解决方法","date":"2022-08-25T14:43:38.000Z","updated":"2022-08-25T15:05:56.583Z","comments":true,"path":"2022/08/25/jiyiciofficewufalianwangjiejuefangfa/","link":"","permalink":"/2022/08/25/jiyiciofficewufalianwangjiejuefangfa/","excerpt":"","text":"登录onedrive显示无法连接服务器解决方法今天更新了一下office三件套，但是更新完之后打开word显示无法连接服务器于是上网搜索后得之可以重置网络。具体操作如下： Cmd + r ：依次输入 netsh int ip reset c:\\resetlog.txt netsh winsock reset shutdown -r -t 0 命令行解析： netsh int ip reset c:\\resetlog.txt 和 netsh winsock reset为重置网络 shutdown -r -t 0 为0s后重启电脑。 重启电脑后再打开word就可以连上网啦！","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"/tags/随笔/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"设计模式之结构型模式","slug":"设计模式之结构型模式","date":"2022-08-25T14:43:05.000Z","updated":"2022-08-25T15:05:10.907Z","comments":true,"path":"2022/08/25/shejimoshizhijiegouxingmoshi/","link":"","permalink":"/2022/08/25/shejimoshizhijiegouxingmoshi/","excerpt":"","text":"结构型模式作用 从程序的结构上实现松耦合，从而可以扩大整体的类结构，用来解决更大的问题。 分类 适配器模式 代理模式 桥接模式 装饰模式 组合模式 外观模式 享元模式 适配器模式 将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。 角色分析 目标接口：客户所期待的接口，目标可以是具体的或抽象的类，也可以是接口。 需要适配的类：需要适配的类或适配者类。 适配器：通过包装一个需要适配的对象，把原接口转换成目标对象。 优缺点优点 一个对象适配器可以把多个不同的适配者适配到同一个目标 可以适配一个适配者的子类，由于适配器和适配者之间是关联关系，根据“里氏代换原则”，适配者的子类也可以通过该适配器进行适配 缺点 对于Java、C#等不支持多重类继承的语言，一次最多只能适配一个适配者类，不能同时适配多个适配者； 对于Java、C#等语言中，类适配模式中的目标抽象类只能为借口，不能为类，其使用有一定局限性。 适用场景 系统需要使用一些现有的类，而这些类的接口（方法名）不符合系统的需要，甚至没有这些类的源代码。 想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。 代码以网线适配器为例： package com.design_patterns.adapter; /** * @Author {xiheya} * @Date: 2022/03/20/ 23:06 * @Description */ //客户端类：电脑 public class Computer { //我们的电脑需要连接上转接器才可以上网 public void net(NetToUsb adapter){ //上网的具体实现，找一个转接头 adapter.handleRequest(); } public static void main(String[] args) { //电脑 Computer computer = new Computer(); //网线 Adaptee adaptee = new Adaptee(); //适配器 Adapter adapter = new Adapter(); computer.net(adapter); System.out.println(\"==========================\"); Adapter2 adapter2 = new Adapter2(adaptee); computer.net(adapter2); } } /** * //要被适配的类：网线 * public class Adaptee { * public void request(){ * System.out.println(\"连接网线开始上网\"); * } * } * * //接口转换器的抽象实现 * public interface NetToUsb { * //作用：处理请求 网线---》USB * public void handleRequest(); * } * * // 1. 继承（类适配器，单继承有局限性） * public class Adapter extends Adaptee implements NetToUsb{ * @Override * public void handleRequest() { * System.out.println(\"我是通过类适配器实现的上网功能（继承）\"); * super.request(); * } * } * * // 2. 组合（对象适配器，常用） * public class Adapter2 implements NetToUsb{ * private Adaptee adaptee; * * public Adapter2(Adaptee adaptee) { * this.adaptee = adaptee; * } * * @Override * public void handleRequest() { * System.out.println(\"我是通过对象适配器实现的上网功能（组合）\"); * adaptee.request(); * } * } */ 结果 流程图 桥接模式定义桥接模式是将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为（Handle and Body）模式或接口（Interface）模式。 实例模型 分析：这个场景中有两个变化的维度：品牌，类型。 代码package com.design_patterns.bridge; /** * @Author {xiheya} * @Date: 2022/03/21/ 15:10 * @Description */ public class Test { public static void main(String[] args) { // Computer computer = new Desktop(new Apple()); computer.info(); // Computer computer1 = new Laptop(new Lenovo()); computer1.info(); // Computer computer2 = new Pad(new Apple()); computer2.info(); } } /** * public interface Brand { * * void info(); * } * * public class Apple implements Brand{ * * @Override * public void info() { * System.out.print(\"苹果\"); * } * } * * public class Lenovo implements Brand{ * * @Override * public void info() { * System.out.print(\"联想\"); * } * } * * public abstract class Computer { * //组合 品牌 * protected Brand brand; * * public Computer(Brand brand) { * this.brand = brand; * } * //自带品牌 * public void info(){ * brand.info(); * } * } * * class Desktop extends Computer { * public Desktop(Brand brand) { * super(brand); * * } * * @Override * public void info() { * super.info(); * System.out.println(\"台式机\"); * } * } * * class Laptop extends Computer { * public Laptop(Brand brand) { * super(brand); * * } * * @Override * public void info() { * super.info(); * System.out.println(\"笔记本\"); * } * } * * class Pad extends Computer { * public Pad(Brand brand) { * super(brand); * * } * * @Override * public void info() { * super.info(); * System.out.println(\"平板\"); * } * } */ 运行结果 结构图 优缺点优点 桥接模式偶尔类似于多继承方案，但是多继承方案违背了类的单一职责原则，复用性比较差，类的个数也非常多，桥接模式是比多集成方案更好的解决方法，极大的减少了子类的个数，从而降低了管理和维护成本。 桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。符合开闭原则，就像一座桥，可以把两个变化的维度连接起来。 缺点 桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性 适用场景 如果一个系统需要在构建的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响，在程序运作时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合 一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。 虽然在系统中使用继承时没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者。对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 场景 Java语言通过Java虚拟机实现了平台无关性， AWT的Peer架构 JDBC驱动程序也是桥接模式的应用之一。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"/tags/设计模式/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"设计模式之创建者模式","slug":"设计模式之创建者模式","date":"2022-08-25T14:42:54.000Z","updated":"2022-08-25T15:05:24.933Z","comments":true,"path":"2022/08/25/shejimoshizhichuangjianzhemoshi/","link":"","permalink":"/2022/08/25/shejimoshizhichuangjianzhemoshi/","excerpt":"","text":"GOF23创建型模式 单例模式 工厂模式 抽象工厂模式 建造者模式 原型模式 结构性模式 适配器模式 桥接模式 装饰模式 组合模式 外观模式 享元模式 代理模式 行为型模式 模板方法模式 命令模式 迭代器模式 观察者模式 中介者模式 备忘录模式 解释器模式 状态模式 策略模式 职责链模式 访问者模式 创建型模式单例模式饿汉单例模式代码package com.xiheya.single; /** * @Author {xiheya} * @Date: 2022/03/15/ 16:44 * @Description */ //饿汉单例模式 public class Hungry { //可能会浪费空间，尽管对象空间没有被使用，但是还是会被开辟出来。 private byte[] data1 = new byte[1024*1024]; private byte[] data2 = new byte[1024*1024]; private byte[] data3 = new byte[1024*1024]; private byte[] data4 = new byte[1024*1024]; private Hungry(){ } private final static Hungry HUNGRY = new Hungry(); public static Hungry getInstance(){ return HUNGRY; } } 存在的问题 可能会浪费空间，尽管对象空间没有被使用，但是还是会被开辟出来。 懒汉式单例代码package com.xiheya.single; /** * @Author {xiheya} * @Date: 2022/03/16/ 10:10 * @Description */ public class LazyMan { // 1.构造器私有化 private LazyMan(){ } // 2.实例化对象 private volatile static LazyMan lazyMan; //给lazyMan加上volatile可以避免指令重排 保证其原子性操作。 //双重检测锁模式的 懒汉式单例 DLC懒汉式 public static LazyMan getInstance(){ if (lazyMan == null){ synchronized (LazyMan.class){ if (lazyMan == null){ lazyMan = new LazyMan(); //不是一个原子性操作 /** * 1.分配内存空间 * 2.执行构造方法，初始化对象 * 3.把这个对象指向这个空间 * 就有可能会出现指令重排现象 * * 正常：123 * 异常：132 * 当A线程进来时 执行了132---先分配内存空间，然后把对象指向这个空间 先占用这个空间，最后再初始化对象，给其赋值 * 恰巧此时B线程进来了，他执行123操作，但是因为A线程先占用了空间，让B线程误以为对象不为null，所以他会不执行if语句，直接return一个lazyMan对象 * */ } } } return lazyMan; } } 注意点 懒汉模式对象如果不加volatile就会出现指令重排。 而我们要保证其多线程安全，就需要加上双重锁 synchronized (LazyMan.class){ if (lazyMan == null){ lazyMan = new LazyMan(); //不是一个原子性操作 } 静态内部类代码package com.xiheya.single; /** * @Author {xiheya} * @Date: 2022/03/16/ 15:13 * @Description */ public class Holder { //1.构造器私有化 private Holder(){ } //从静态内部类里返回HOLDER； public static Holder getInstance(){ return InnerClass.HOLDER; } //静态内部类 public static class InnerClass{ private static final Holder HOLDER = new Holder(); } } 单例不安全，因为有反射。反射会破坏单例 所以为了解决这个问题我们使用枚举来实现单例模式。 枚举单例模式代码package com.xiheya.single; /** * @Author {xiheya} * @Date: 2022/03/16/ 15:19 * @Description */ public enum EnumSingle { INSTANCE; public EnumSingle getInstance(){ return INSTANCE; } } 因为反射不能破解枚举，所以我们使用枚举来实现单例模式。 工厂模式作用 实现了创建者和调用者的分离 详细分类： 简单工厂模式 工厂方法模式 抽象工厂模式 OOP七大原则 开闭原则：一个软件的实体应当对扩展开放，对修改关闭。 依赖倒转原则：要针对接口编程，不要针对实现编程。 迪米特法则：只与你直接的朋友通信，而避免和陌生人通信。 核心本质 实例化对象不适用new，用工厂方法代替 将选择实现类，创建对象统一管理和控制，从而将调用者跟我们的实现类解耦 三种模式： 简单工厂模式 用来生产同一等级结构中的任意产品（对于增加新的产品，需要球盖已有代码） 工厂方法模式 用来生产同一等级结构中的固定产品（支持增加任意产品） 抽象工厂模式 围绕一个超级工厂创建其他工厂。该工厂又称为其他工厂的工厂。 简单工厂模式代码package com.xiheya.factory.simple; /** * @Author {xiheya} * @Date: 2022/03/16/ 15:39 * @Description */ public class Consumer { public static void main(String[] args) { // Car car = new WuLing(); // Car car1 = new Tesla(); Car car = CarFactory.getCar(\"五菱\"); Car car1 = CarFactory.getCar(\"特斯拉\"); car.name(); car1.name(); } } /** * * public interface Car { * void name(); * } * * public class WuLing implements Car { * @Override * public void name() { * System.out.println(\"wuling\"); * } * } * * public class Tesla implements Car{ * @Override * public void name() { * System.out.println(\"Tesla!\"); * } * } * * public class CarFactory { * //方法一 * public static Car getCar(String car){ * if (car.equals(\"五菱\")){ * return new WuLing(); * }else if (car.equals(\"特斯拉\")){ * return new Tesla(); * }else { * return null; * } * } * //方法二 * public static Car getWuLing(){ * return new WuLing(); * } * public static Car getTesla(){ * return new Tesla(); * } * * } */ 弊端 未实现开闭原则 实现结果 流程图 工厂方法模式代码package com.xiheya.factory.method; import com.xiheya.factory.simple.CarFactory; /** * @Author {xiheya} * @Date: 2022/03/16/ 15:39 * @Description */ public class Consumer { public static void main(String[] args) { Car car = new TeslaFactory().getCar(); car.name(); Car car1 = new WuLingFactory().getCar(); car1.name(); Car car2 = new DaZhongFactory().getCar(); car2.name(); } } /** * public interface Car { * void name(); * } * * public interface CarFactory { * Car getCar(); * } * * public class DaZhong implements Car { * @Override * public void name() { * System.out.println(\"DaZhong!\"); * } * } * * public class DaZhongFactory implements CarFactory{ * @Override * public Car getCar() { * return new DaZhong(); * } * } * * public class Tesla implements Car { * @Override * public void name() { * System.out.println(\"Tesla!\"); * } * } * * public class TeslaFactory implements CarFactory{ * @Override * public Car getCar() { * return new Tesla(); * } * } * * public class WuLing implements Car { * @Override * public void name() { * System.out.println(\"wuling\"); * } * } * * public class WuLingFactory implements CarFactory{ * @Override * public Car getCar() { * return new WuLing(); * } * } * * */ 弊端 虽然实现了代码的开闭原则，并且可以动态拓展。但是工厂方法模式实现成本太高了。 实现结果 流程图 小结 简单工厂模式（静态工厂模式） 虽然某种程度上不符合设计原则，但实际使用最多！ 工厂方法模式 不修改已有类的前提下，通过新的工厂类实现扩展 抽象工厂模式 不可以增加产品，可以增加产品族！ 应用场景 JDK中的Calendar的getInstance方法 JDBC中的Connection对象的获取 Spring中IOC容器创建管理bean对象 反射中Class对象的newInstance方法 抽象工厂模式定义 定义：抽象工厂模式提供了一个创建一系列相关或者相互依赖对象的接口，无需指定它们的类 适用场景 客户端（应用层）不依赖于产品类实例如何被创建、实现的细节 强调一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量的重复代码。 提供一个产品类的库，所有产品以同样的接口出现，从而使得客户端不依赖于具体的实现 优点 具体产品在应用层的代码隔离，无需关心创建的细节 将一个系列的产品统一到一起创建 缺点 规定了所有可能被创建的产品集合，产品簇中扩展新的产品困难； 增加了系统的抽象性和理解难度。 代码package com.xiheya.factory.abstract1; /** * @Author {xiheya} * @Date: 2022/03/16/ 17:00 * @Description */ public class Client { public static void main(String[] args) { System.out.println(\"==============小米系列产品================\"); XiaomiFactory xiaomiFactory = new XiaomiFactory(); IPhoneProduct xiaomi = xiaomiFactory.iphoneProduct(); xiaomi.callup(); xiaomi.sendSMS(); IRouterProduct xiaomiRouter = xiaomiFactory.irouterProduct(); xiaomiRouter.openWifi(); xiaomiRouter.setting(); System.out.println(\"==============华为系列产品================\"); HuaweiFactory huaweiFactory = new HuaweiFactory(); IPhoneProduct huawei = huaweiFactory.iphoneProduct(); huawei.callup(); huawei.sendSMS(); IRouterProduct huaweiRouter = huaweiFactory.irouterProduct(); huaweiRouter.openWifi(); huaweiRouter.setting(); } } /** * //抽象产品工厂 * public interface IProductFactory { * //生产手机 * IPhoneProduct iphoneProduct(); * //生产路由器 * IRouterProduct irouterProduct(); * } * * //手机产品接口 * public interface IPhoneProduct { * void start(); * void shutdown(); * void callup(); * void sendSMS(); * } * * //路由器产品接口 * public interface IRouterProduct { * void start(); * void shutdown(); * void openWifi(); * void setting(); * } * * * //华为工厂 * public class HuaweiFactory implements IProductFactory{ * @Override * public IPhoneProduct iphoneProduct() { * return new HuaweiPhone(); * } * * @Override * public IRouterProduct irouterProduct() { * return new HuaweiRouter(); * } * } * * //华为手机 * public class HuaweiPhone implements IPhoneProduct{ * @Override * public void start() { * System.out.println(\"Huawei start\"); * } * * @Override * public void shutdown() { * System.out.println(\"Huawei shutdown\"); * } * * @Override * public void callup() { * System.out.println(\"Huawei callup\"); * } * * @Override * public void sendSMS() { * System.out.println(\"Huawei sendSMS\"); * } * } * * //华为路由器 * public class HuaweiRouter implements IRouterProduct{ * @Override * public void start() { * System.out.println(\"启动华为路由器\"); * } * * @Override * public void shutdown() { * System.out.println(\"关闭华为路由器\"); * } * * @Override * public void openWifi() { * System.out.println(\"华为由器打开WiFi\"); * } * * @Override * public void setting() { * System.out.println(\"配置华为路由器\"); * } * } * * //小米工厂 * public class XiaomiFactory implements IProductFactory{ * @Override * public IPhoneProduct iphoneProduct() { * return new XiaomiPhone(); * } * * @Override * public IRouterProduct irouterProduct() { * return new XiaomiRouter(); * } * } * * //小米手机 * public class XiaomiPhone implements IPhoneProduct{ * @Override * public void start() { * System.out.println(\"xiaomi start\"); * } * * @Override * public void shutdown() { * System.out.println(\"xiaomi shutdown\"); * } * * @Override * public void callup() { * System.out.println(\"xiaomi callup\"); * } * * @Override * public void sendSMS() { * System.out.println(\"xiaomi sendSMS\"); * } * } * * //小米路由器 * public class XiaomiRouter implements IRouterProduct{ * @Override * public void start() { * System.out.println(\"启动小米路由器\"); * } * * @Override * public void shutdown() { * System.out.println(\"关闭小米路由器\"); * } * * @Override * public void openWifi() { * System.out.println(\"小米路由器打开WiFi\"); * } * * @Override * public void setting() { * System.out.println(\"配置小米路由器\"); * } * } * */ 运行结果 流程图 建造者模式定义 建造者模式也属于创建类模式，它提供了一种创建对象的最佳方式。 它将一个复杂对象的构建与他的表示分离，使得同样的构建过程可以创建不同的表示。 主要作用在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象。 用户只需要给出指定复杂对象的类型和内容，建造者模式负责按顺序创建复杂对象（把内部的建造过程和细节隐藏起来） 例子： 工厂（建造者模式）：负责制造汽车（组装过程和细节在工厂内） 汽车购买者（用户）：你只需要说出你需要的型号（对象的类型和内容），然后直接购买就可以使用了（不需要知道汽车是怎么组装的（车轮、车门、发动机、方向盘等等）） 代码package com.design_patterns.builder; /** * @Author {xiheya} * @Date: 2022/03/19/ 15:15 * @Description */ public class Test { public static void main(String[] args) { //新建一个指挥 Director director = new Director(); //指挥 工人盖房子 Product build = director.build(new Worker()); System.out.println(build.toString()); } } /** * //抽象的建造者方法：盖房子 * public abstract class Builder { * * abstract void builderA(); //地基 * abstract void builderB(); //钢筋工程 * abstract void builderC(); //铺电线 * abstract void builderD(); //粉刷 * //完工：得到产品 * abstract Product getProduct(); * } * * public class Product { * private String buildA; * private String buildB; * private String buildC; * private String buildD; * * public String getBuildA() { * return buildA; * } * * public String getBuildB() { * return buildB; * } * * public String getBuildC() { * return buildC; * } * * public String getBuildD() { * return buildD; * } * * public void setBuildA(String buildA) { * this.buildA = buildA; * } * * public void setBuildB(String buildB) { * this.buildB = buildB; * } * * public void setBuildC(String buildC) { * this.buildC = buildC; * } * * public void setBuildD(String buildD) { * this.buildD = buildD; * } * * @Override * public String toString() { * return \"Product{\" + * \"buildA='\" + buildA + '\\'' + * \", buildB='\" + buildB + '\\'' + * \", buildC='\" + buildC + '\\'' + * \", buildD='\" + buildD + '\\'' + * '}'; * } * * } * * //具体的建造者：工人 * public class Worker extends Builder{ * private Product product; * * public Worker() { * product = new Product(); //工人负责创建产品 * } * * @Override * void builderA() { * product.setBuildA(\"打好了地基\"); * System.out.println(product.getBuildA()); * } * * @Override * void builderB() { * product.setBuildB(\"铺好了钢筋\"); * System.out.println(product.getBuildB()); * } * * @Override * void builderC() { * product.setBuildC(\"铺好了电线\"); * System.out.println(product.getBuildC()); * } * * @Override * void builderD() { * product.setBuildD(\"粉好了墙壁\"); * System.out.println(product.getBuildD()); * } * * @Override * Product getProduct() { * return product; * } * } * * //指挥：核心，负责构建一个工程，工程如何创建 由他决定。 * public class Director { * * // 指挥工人建造房子 * public Product build(Builder builder){ * builder.builderA(); * builder.builderB(); * builder.builderC(); * builder.builderD(); * //建造完成后返回一个房子； * return builder.getProduct(); * } * } * * */ 运行结果 上面示例是Builder模式的常规用法，导演类Director在Builder模式中具有很重要的作用，它用于指导具体构建者如何构建产品，控制调用先后次序，并向调用着返回完整的产品类，但是有些情况下需要简化系统结构，可以把Director和抽象建造者进行结合。 通过静态内部类方式实现零件无序装配构造，这种方式使用更加灵活，更符合定义。内部有复杂对象的默认实现，使用时可以根据用户需求自由定义更改内容，并且无需改变具体的构造方式。就可以生产出不同复杂产品。 比如:麦当劳的套餐，服务员（具体建造者）可以随意搭配任意几种产品（零件）组成一款套餐（产品），然后出售给客户。彼地种方式少了指挥者，主要是因为第二种方式把指挥者交给用户来操作，使得产品的创建更加简单灵活。 无指挥类的建造者模式代码package com.design_patterns.builder.demo02; /** * @Author {xiheya} * @Date: 2022/03/20/ 20:54 * @Description */ public class Test { public static void main(String[] args) { //服务员 Worker worker = new Worker(); //链式编程，在原来的基础上可以自由组合，如果组合，则返回默认套餐。 Product product = worker.buildA(\"炸鸡\").buildB(\"芬达\").getProduct(); System.out.println(product.toString()); } } /** * //建造者 * public abstract class Builder { * abstract Builder buildA(String msg); //汉堡 * abstract Builder buildB(String msg); //薯条 * abstract Builder buildC(String msg); //可乐 * abstract Builder buildD(String msg); //甜点 * * abstract Product getProduct(); * } * * public class Product { * private String BuildA = \"汉堡\"; * private String BuildB = \"可乐\"; * private String BuildC = \"薯条\"; * private String BuildD = \"甜点\"; * * public String getBuildA() { * return BuildA; * } * * public void setBuildA(String buildA) { * BuildA = buildA; * } * * public String getBuildB() { * return BuildB; * } * * public void setBuildB(String buildB) { * BuildB = buildB; * } * * public String getBuildC() { * return BuildC; * } * * public void setBuildC(String buildC) { * BuildC = buildC; * } * * public String getBuildD() { * return BuildD; * } * * public void setBuildD(String buildD) { * BuildD = buildD; * } * * @Override * public String toString() { * return \"Product{\" + * \"BuildA='\" + BuildA + '\\'' + * \", BuildB='\" + BuildB + '\\'' + * \", BuildC='\" + BuildC + '\\'' + * \", BuildD='\" + BuildD + '\\'' + * '}'; * } * } * * //具体的建造者 * public class Worker extends Builder{ * private Product product; * * public Worker() { * product = new Product(); * } * * @Override * Builder buildA(String msg) { * product.setBuildA(msg); * return this; * } * * @Override * Builder buildB(String msg) { * product.setBuildB(msg); * return this; * } * * @Override * Builder buildC(String msg) { * product.setBuildC(msg); * return this; * } * * @Override * Builder buildD(String msg) { * product.setBuildD(msg); * return this; * } * * @Override * Product getProduct() { * return product; * } * } * */ 运行结果 优缺点优点 产品的建造和表示分离，实现了解耦。使用建造者模式可以使客户端不必知道产品内部组成的细节。 将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰. 具体的建造者类之间是相互独立的，这有利于系统的扩展。增加新的具体建造者无需修改原有类库的代码，符合“开闭原则” 缺点 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似；如果产品之间的差异性很大，则不适合使用建造者模式，因此其适用范围受到一定的限制。 如果产品的内部变化复杂，可能会导致需要定义很多具体建造类来实现这种变化，导致系统变得很庞大。 应用场景 需要生产的产品对象有复杂的内部结构，这些产品对象具有共性。 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品、 适合于一个具有较多的零件（属性）的产品（对象）的创建过程。 建造者与抽象工厂模式的比较 与抽象工厂模式相比，建造者模式返回一个组装好的完整产品，而抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族。 在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象。 如果将抽象工厂模式堪称汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。 原型模式实现步骤 实现一个接口：Cloneable; 重写一个方法：clone(); 主要用于：Spring Bean：单例模式，原型模式 原型模式+工厂模式 ===&gt; new &lt;=&gt; 原型模式 浅克隆模式代码package com.design_patterns.prototype.demo01; import java.util.Date; /** * @Author {xiheya} * @Date: 2022/03/20/ 21:29 * @Description */ //客户端 public class Bilibili { public static void main(String[] args) throws CloneNotSupportedException { //原型对象 v1 Date date = new Date(); Video v1 = new Video(\"xiheya\",date); //克隆对象 v2 Video v2 =(Video) v1.clone(); System.out.println(\"v1-->\" + v1); System.out.println(\"v1:hashcode-->\" + v1.hashCode()); System.out.println(\"v2-->\" + v2); System.out.println(\"v2:hashcode-->\" + v2.hashCode()); System.out.println(\"====================================\"); date.setTime(123456); System.out.println(\"v1-->\" + v1); System.out.println(\"v1:hashcode-->\" + v1.hashCode()); System.out.println(\"v2-->\" + v2); System.out.println(\"v2:hashcode-->\" + v2.hashCode()); System.out.println(\"====================================\"); } } /** * //原型模式的实现： * // 1.实现一个接口：Cloneable; * // 2.重写一个方法：clone(); * // Video * public class Video implements Cloneable{ * private String name; * private Date creatTime; * * @Override * protected Object clone() throws CloneNotSupportedException { * return super.clone(); * } * * public Video() { * } * * public Video(String name, Date creatTime) { * this.name = name; * this.creatTime = creatTime; * } * * public String getName() { * return name; * } * * public void setName(String name) { * this.name = name; * } * * public Date getCreatTime() { * return creatTime; * } * * public void setCreatTime(Date creatTime) { * this.creatTime = creatTime; * } * * @Override * public String toString() { * return \"Video{\" + * \"name='\" + name + '\\'' + * \", creatTime=\" + creatTime + * '}'; * } * } */ 结果 深克隆模式代码package com.design_patterns.prototype.demo02; import java.util.Date; /** * @Author {xiheya} * @Date: 2022/03/20/ 21:29 * @Description */ //客户端 public class Bilibili { public static void main(String[] args) throws CloneNotSupportedException { //原型对象 v1 Date date = new Date(); Video v1 = new Video(\"xiheya\",date); //克隆对象 v2 Video v2 =(Video) v1.clone(); System.out.println(\"v1-->\" + v1); System.out.println(\"v1:hashcode-->\" + v1.hashCode()); System.out.println(\"v2-->\" + v2); System.out.println(\"v2:hashcode-->\" + v2.hashCode()); System.out.println(\"====================================\"); date.setTime(123456); System.out.println(\"v1-->\" + v1); System.out.println(\"v1:hashcode-->\" + v1.hashCode()); System.out.println(\"v2-->\" + v2); System.out.println(\"v2:hashcode-->\" + v2.hashCode()); System.out.println(\"====================================\"); } } /** * //原型模式的实现： * // 1.实现一个接口：Cloneable; * // 2.重写一个方法：clone(); * // Video * public class Video implements Cloneable{ * private String name; * private Date creatTime; * * @Override * protected Object clone() throws CloneNotSupportedException { * Object obj = super.clone(); * //深克隆，序列化与反序列化 * Video v = (Video) obj; * v.creatTime = (Date) this.creatTime.clone();//将对象的属性也序列化 * return obj; * } * * public Video() { * } * * public Video(String name, Date creatTime) { * this.name = name; * this.creatTime = creatTime; * } * * public String getName() { * return name; * } * * public void setName(String name) { * this.name = name; * } * * public Date getCreatTime() { * return creatTime; * } * * public void setCreatTime(Date creatTime) { * this.creatTime = creatTime; * } * * @Override * public String toString() { * return \"Video{\" + * \"name='\" + name + '\\'' + * \", creatTime=\" + creatTime + * '}'; * } * } */ 结果 浅克隆与深克隆对比 浅克隆:克隆出来的对象和原型共同指向一个对象，克隆对象只是引用了这个对象。 深克隆：克隆出来的对象会把原型的属性也克隆出来。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"/tags/设计模式/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"排序算法","slug":"排序算法","date":"2022-08-25T14:42:35.000Z","updated":"2022-08-25T15:05:37.578Z","comments":true,"path":"2022/08/25/paixusuanfa/","link":"","permalink":"/2022/08/25/paixusuanfa/","excerpt":"","text":"冒泡排序代码：package com.xiheya.sort; /** * @Author {xiheya} * @Date: 2022/03/16/ 17:21 * @Description */ public class BubbleSort { public static void main(String[] args) { int[] arr = {1,3,2,6,5,9,4}; bubbleSort(arr); System.out.print(\"finish: [\" ); for (int x : arr) { System.out.print(x + \"\\t\"); } System.out.println(\"]\"); } public static void bubbleSort(int[] arr){ for (int i = 0; i &lt; arr.length - 1; i++) { for (int j = 0; j &lt; arr.length - 1 -i; j++){ if (arr[j] > arr[j+1]) { int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } } } } } 运行结果 冒泡排序的优化代码package com.xiheya.sort; /** * @Author {xiheya} * @Date: 2022/03/16/ 17:21 * @Description */ public class BubbleSort { public static void main(String[] args) { int[] arr = {1,3,2,6,5,9,4}; bubbleSort(arr); System.out.print(\"finish: [\" ); for (int x : arr) { System.out.print(x + \"\\t\"); } System.out.println(\"]\"); } public static void bubbleSort(int[] arr){ for (int i = 0; i &lt; arr.length - 1; i++) { //确定冒泡次数 //如果在某一次冒泡排序过程中，没有交换元素，则说明该数组已经有序。 //冒泡步骤 boolean flag = true; for (int j = 0; j &lt; arr.length - 1 -i; j++){ if (arr[j] > arr[j+1]) { flag = false; int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } } if (flag){ break; } } } } 运行结果 选择排序代码package com.xiheya.sort; /** * @Author {xiheya} * @Date: 2022/03/16/ 17:40 * @Description */ public class SelectSort { public static void main(String[] args) { int[] arr = {1,3,-2,4,5}; selectSort(arr); for (int i : arr) { System.out.print(i + \" \"); } } public static void selectSort(int[] arr){ for (int i = 0; i &lt; arr.length - 1; i++) { //开始选择排序 //初始 min = arr[i]; mindex = i; int min = arr[i]; int mindex = i; for (int j = i + 1; j &lt; arr.length - 1 ; j++){ //将min与其后面的数比较，如果min大于他后面的数 就更新min，及其下标 if (min > arr[j]){ min = arr[j]; mindex = j; } } //如果 最小值的下标不等于 i 则交换 这两个元素的值 if (mindex != i){ arr[mindex] = arr[i]; arr[i] = min; } } } } 运行结果 插入排序代码package com.xiheya.sort; /** * @Author {xiheya} * @Date: 2022/03/16/ 18:08 * @Description */ public class InsertSort { public static void main(String[] args) { int[] arr = {1,3,2,5,4,-1}; insertSort(arr); for (int i : arr) { System.out.print(i + \" \"); } } public static void insertSort(int[] arr) { for (int i = 1; i &lt; arr.length; i++) { //初始化insertdex 和 insertvalue int insertdex = i; int insertvalue = arr[i]; while (insertdex > 0 &amp;&amp; insertvalue &lt; arr[insertdex - 1]){ //while循环，当insertdex > 0 以及 insertvalue 小于 其前一个值时进入循环 // 将 前一个值 赋值给 下标为 insertdex的数组空间内 arr[insertdex] = arr[insertdex - 1]; // 下标往前移一位 insertdex--; } //当下标等于0 或者前面的数据均没有比insertvalue小时 结束循环，将insertvalue的值赋给 arr[insertdex] arr[insertdex] = insertvalue; } } } 运行结果 快速排序代码package com.xiheya.sort; /** * @Author {xiheya} * @Date: 2022/03/16/ 19:34 * @Description */ public class QuickSort { public static void main(String[] args) { int[] arr ={1,3,-2,4,5,6}; quickSort(arr,0,arr.length - 1); for (int i : arr) { System.out.print(i + \" \"); } } public static void quickSort(int[] arr,int left, int right){ //递归退出条件 if (left >= right){ return; } //左指针与右指针 int l = left; int r = right; while (l &lt; r){ while (l &lt; r &amp;&amp; arr[r] >= arr[left])r--; //右边的元素与arr[left]比较，直到出现一个比arr[left]小的数，r指针停止左移 while (l &lt; r &amp;&amp; arr[l] &lt;= arr[left])l++; //左边的元素与arr[left]比较，直到出现一个比arr[left]大的数，l指针停止右移 if (l == r){ //当两个指针相遇时交换 arr[l]（arr[r]） 与 arr[left]的数据 int temp = arr[l]; arr[l] = arr[left]; arr[left] = temp; }else{ //两个指针不相等时则交换 两指针内的数据 int temp = arr[r]; arr[r] = arr[l]; arr[l] = temp; } } quickSort(arr,left,l-1); //通过递归，将左边的元素进行快排 quickSort(arr,r+1,right); //通过递归，将右边的元素进行快排。 } } 运行结果 归并排序代码package com.xiheya.sort; import java.util.Arrays; /** * @Author {xiheya} * @Date: 2022/03/16/ 23:53 * @Description */ public class MergeSort { public static void main(String[] args) { int[] arr = {1,3,2,6,4,9,7}; int[] temp = new int[arr.length]; mergeSort(arr,0, arr.length - 1, temp); System.out.println(Arrays.toString(arr)); } public static void mergeSort(int[] arr, int left, int right, int[] temp){ if (left &lt; right){ int mid = (left + right) / 2; //分 mergeSort(arr,0,mid,temp); //将左边部分继续分 mergeSort(arr,mid+1,right,temp); //将右边部分继续分 //合 merge(arr,left,mid,right,temp); } } //合 public static void merge(int[] arr, int left, int mid, int right, int[] temp) { int i = left; int j = mid+1; int t = 0; //临时数组下标索引 //先将两部分合并 while (i &lt;= mid &amp;&amp; j &lt;= right){ if (arr[i] &lt;= arr[j]){ temp[t] = arr[i]; i++;t++; }else { temp[t] = arr[j]; j++;t++; } } //如果左边没有合并完全，则接着i继续合并 while (i &lt;= mid){ temp[t] = arr[i]; t++;i++; } //如果右边没有合并完全，则接着j继续合并 while (j &lt;= right){ temp[t] = arr[j]; t++;j++; } //接着将temp中的数组填充到指定位置 t = 0; int templeft = left; while (templeft &lt;= right){ arr[templeft] = temp[t]; t++;templeft++; } } } 运行结果 基数排序代码package com.xiheya.sort; import java.util.Arrays; /** * @Author {xiheya} * @Date: 2022/03/17/ 0:45 * @Description */ public class RedixSort { public static void main(String[] args) { int[] arr = {10023,3225,302,155,9,3326,33,5987,663,15596}; redixSort(arr); System.out.println(Arrays.toString(arr)); } public static void redixSort(int[] arr){ int[][] bucket = new int[10][arr.length - 1]; //桶里面所存的具体数值 int[] bucketElementCounts = new int[10]; //每个桶所存的元素个数 int max = arr[0]; for (int i = 1; i &lt; arr.length; i++) { if(max &lt; arr[i]) max = arr[i]; } int maxCount = (max + \"\").length(); //获取最大数的位数 for (int i = 0; i &lt; maxCount; i++) { //把数组中的数都放在桶里面 for (int k = 0; k &lt; arr.length; k++) { int value = arr[k] / (int) Math.pow(10, i) % 10; bucket[value][bucketElementCounts[value]] = arr[k]; bucketElementCounts[value]++; } int index = 0; for (int k = 0; k &lt; bucketElementCounts.length; k++) { if(bucketElementCounts[k] != 0){ for (int x = 0; x &lt; bucketElementCounts[k]; x++) { arr[index] = bucket[k][x]; index++; } } bucketElementCounts[k] = 0; } } } } 运行结果","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"},{"name":"排序算法","slug":"排序算法","permalink":"/tags/排序算法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Java基础小结","slug":"Java基础小结","date":"2022-08-25T14:42:17.000Z","updated":"2022-08-25T15:04:26.063Z","comments":true,"path":"2022/08/25/javajichuxiaojie/","link":"","permalink":"/2022/08/25/javajichuxiaojie/","excerpt":"","text":"面向过程&amp; 面向对象面向过程思想—&gt;自上而下面向对象就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。 步骤清晰简单，第一步做什么，第二步做什么…… 面向过程适合处理一些较为简单的问题 面向对象思想—&gt;自下而上面向对象就是根据类创建对象，每个对象都有自己的属性和方法，而这些属性和方法都是围绕对象服务的，你会发现用到的属性和方法都是对象。 物以类聚，分类的思维模式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独思考。最后，才对某个分类下的细节进行面向过程的思索。 面向对象适合处理复杂的问题，适合处理需要多人协作的问题。 对于描述复杂的事物，为了从宏观上把握，从整体上合理分析，我们需要使用面向对象的思路来分析整个系统。但是，具体到微观操作，仍然需要面向过程的思路去处理。 什么是面向对象 面向对象编程（Object_Oriented Programming， OOP） 面向对象编程的本质就是：以类的方式组织代码，以对象的形式（封装）数据 抽象 —&gt;将有共同特征的物体抽象成一个类，比如泰迪、哈士奇、金毛，他们都有个共同的特征，那就是他们都是狗。 三大特征 封装 继承 多态 从认识论的角度考虑：先有对象后有类。对象，是具体的事物。类，是抽象的，是对对象的抽象 从代码运行的角度考虑，是先有类后有对象。类是对象的模板。 回顾方法及加深方法的定义 修饰符 返回类型 break：（跳出switch，结束循环） 和 return（结束方法，返回一个结果）的区别 方法名：注意规范就可以（首字母小写驼峰法），见名知意 参数列表：（参数类型，参数名）…… 异常抛出： 方法的调用:递归 静态方法 非静态方法 package com.xiheya.oop; /** * @Author {xiheya} * @Date: 2022/03/12/ 22:30 * @Description */ public class Demo02 { public static void main(String[] args) { Demo02 demo02 = new Demo02(); int sum = demo02.add(1, 2); //实例化对象demo02后，才可以调用非静态方法add System.out.println(sum); System.out.println(add(1, 2, 3)); //而静态方法add则可以直接调用 } public static int add(int a,int b, int c){ //静态方法，main方法中可以直接调用。 return a+b+c; } public int add(int a,int b){ //非静态方法，调用的话需要实例化对象后才能调用。 return a+b; } } 形参和实参 值传递和引用传递 代码： package com.xiheya.oop; /** * @Author {xiheya} * @Date: 2022/03/12/ 21:52 * @Description */ // 值传递和引用传递 public class Demo01 { public static void main(String[] args) { int a = 1; System.out.println(a); change(a); //调用change方法时，传给chang的只是a的值，change方法中对a的一系列操作均不会对main中的a产生影响 System.out.println(a); //可以看到尽管在change方法中对a进行了赋值操作，但仍然没有改变a的值。这就是Java的值传递。 Person person = new Person(); //实例化一个类，new一个Person类。 System.out.println(person.name); changeName(person); //由于传递给changeName方法的是一个类对象，方法对person.name 的修改是对Person类中 name的修改，所以是一定可以修改成功的， System.out.println(person.name); //这就是引用传递（实质上还是值传递） } public static void change(int a){ a = 10; } public static void changeName(Person person){ //person是一个对象，指向的是Person这个类，这是一个具体的人，可以改变属性 person.name = &quot;xiheya&quot;; } } class Person{ String name; } 运行结果： this关键字 类与对象的关系 类是一种抽象的数据类型，它是对某一类事物整体描述/定义，但是并不能代表某一个具体的事物。 动物、植物、手机、电脑 Person类、Pet类、Car类等，这些类都是用来描述/定义某一类具体的事物应该具备的特点和行为 对象是抽象概念的具体实例 eg：张三就是人的一个具体实例，而张三家的旺财就是狗的一个具体实例 能够体现出特点，展现出功能的是具体的实例，而不是一个抽象的概念。 创建和初始化对象 使用new关键字创建对象 使用new关键字创建的时候，除了分配内存空间之外，还会给创建好的对象进行默认的初始化以及对类中构造器的调用。 类中的构造器也称为构造方法，是在进行创建对象的时候必须要调用的。并且构造器有以下两个特点： 1.必须和类的名字相同 2.必须没有返回类型，也不能写void 构造器方法必须掌握","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"},{"name":"Java基础语法","slug":"Java基础语法","permalink":"/tags/Java基础语法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Java异常02","slug":"Java异常02","date":"2022-08-25T14:42:06.000Z","updated":"2022-08-25T15:02:18.233Z","comments":true,"path":"2022/08/25/javayichang02/","link":"","permalink":"/2022/08/25/javayichang02/","excerpt":"","text":"捕获异常try catch关键字 try：监控类型 catch：想要捕获的异常，可以捕获异常 finally：可以处理善后工作，（可以不要finally） 使用 try catch关键字可以在出现异常时实现程序不终止，继续跑完程序。我们只需要在try catch中处理这些异常就可以了。 package com.xiheya.exception; /** * @Author {xiheya} * @Date: 2022/03/14/ 9:47 * @Description */ public class Test { public static void main(String[] args) { //假设要捕获多个异常：我们要从小到大的去捕获 // 快捷键 Ctrl + Alt + T 快速捕获异常。 try{ //try 监控类型 int a = 1; int b = 0; System.out.println(a/b); }catch (ArithmeticException e){ //catch（想要捕获的异常类型0 捕获异常） System.out.println(\"程序出现异常，b不能为0\"); }finally { //处理善后工作。可以不要finally，假设IO，资源 关闭 System.out.println(\"finally\"); } } } throw 和 throws关键字 throw关键字一般是在方法体内主动抛出异常 throws关键字一般是在方法名中抛出异常 public class Test { public static void main(String[] args) { int a = 1; int b = 0; try { new Test().test(1,0); } catch (ArithmeticException e) { e.printStackTrace(); } finally { } } public void test (int a , int b)throws ArithmeticException{ if (b == 0){ throw new ArithmeticException(); } } } 自定义异常 使用Java内置的异常类可以描述在编程时出现的大部分异常情况。除此之外，用户还可以自定义异常。用户自定义异常类，只需要继承Exception类即可。 在程序中使用自定义异常类，大体可以分为以下几个步骤： 创建自定义异常类。 在方法中通过throw关键字抛出异常对象。 如果在当前抛出异常的方法中处理异常，可以使用try-catch语句捕获并处理；否则在方法的声明处通过throws关键字指明要抛出给方法调用者的异常，继续进行下一步。 再出现异常方法的调用者中捕获并处理异常。 代码package com.xiheya.exception.demo02; /** * @Author {xiheya} * @Date: 2022/03/15/ 0:23 * @Description */ public class Test { static void test(int a) throws MyException { if (a > 10){ throw new MyException(a); } } public static void main(String[] args) { try { test(11); } catch (MyException e) { System.out.println(\"my exception\"+ e); } } } /* public class MyException extends Exception{ private int detail; public MyException(int a) { this.detail = a; } @Override public String toString() { return \"MyException{\" + \"detail=\" + detail + '}'; } } */ 运行结果 经验总结 处理运行时异常时，采用逻辑去合理规避同时辅助try-catch处理 在多重catch块后面，可以加一个catch（Exception）来处理可能会被漏掉的异常。 对于不确定的代码，也可以加上一个try-catch，处理潜在的异常。 尽量去处理异常，切忌只是简单地调用printStackTrace()去打印输出 具体如何处理异常，要根据不同的业务需求和异常类型去决定 尽量添加finally语句块去释放占用的资源。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"},{"name":"Java异常","slug":"Java异常","permalink":"/tags/Java异常/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Java异常01","slug":"Java异常01","date":"2022-08-25T14:42:03.000Z","updated":"2022-08-25T15:02:07.903Z","comments":true,"path":"2022/08/25/javayichang01/","link":"","permalink":"/2022/08/25/javayichang01/","excerpt":"","text":"异常定义 实际工作中，遇到的情况不可能是非常完美的。比如：你写的某个模块，用户输入不一定符合你的要求、你的程序要打开某个文件，这个文件可能不存在或者文件格式不对，你要读取数据库的数据，数据可能是空的等。我们的程序在跑着，内存或硬盘可能就满了。等等 软件程序再运行过程中，非常可能遇到刚刚提到的这些异常问题，我们叫异常，英文是：Exception，意思是例外。这些，例外情况，或者叫异常，怎么让我们写的程序做出合理的处理，而不至于程序崩溃？ 异常指程序运行中出现的不期而至的各种状况，如：文件找不到、网络连接失败、非法参数等。 异常发生在程序运行期间，他影响了程序正常的程序执行流程 分类简单分类需要掌握以下三种类型的异常 检查性异常：最具代表的检查性异常时用户错误或问题引起的异常，这是程序羊无法预见的。例如要打开一个不存在的文件时，一个异常就发生了，这些异常在编译时不能被简单的忽略 运行时异常：运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。 错误ERROR：错误不是异常，而是脱离程序员控制的问题，错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，他们在编译时也检查不到的。 异常体系结构 Java把异常当作对象来处理，并定义一个基类java.lang,Throwable作为所有异常的超类 在Java API中已经定义了许多异常类，这些异常类分为两大类：错误ERROR和异常Exception ERROR Error类对象是由Java虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。 Java虚拟机运行时错误（Virtual MachineError），当JVM不再有继续执行操作所需的内存资源时将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止； 还有发生在虚拟机试图执行应用时，如类定义错误（NoClassDefFoundError）、链接错误（LinkageError）。这些错误时不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数时程序运行时不允许出现的状况。 Exception 在Exception分支中有一个重要的子类RuntimeException（运行时异常） ArrayIndexOutOfBoundsException（数组下标越界异常） NullPointerException（空指针异常） ArithmeticException（算数异常） MissingResourceException（丢失资源） ClassNotFoundException（找不到类）等异常 这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生； Error和Exception的区别：Error通常时灾难性的致命的错误，是程序无法控制和处理的，当出现这些异常时，Java虚拟机（JVM）一般会选择终止线程；Exception通常情况下时可以被程序处理的，并且在程序中应该尽可能地去处理这些异常。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"},{"name":"Java异常","slug":"Java异常","permalink":"/tags/Java异常/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Java面向对象04","slug":"Java面向对象04","date":"2022-08-25T14:41:51.000Z","updated":"2022-08-25T15:03:18.064Z","comments":true,"path":"2022/08/25/javamianxiangduixiang04/","link":"","permalink":"/2022/08/25/javamianxiangduixiang04/","excerpt":"","text":"static 关键字静态变量与静态方法 静态的变量 多线程中会用到(包含static关键字) 非静态的变量（不包含static关键字） 非静态方法中可以直接调用静态方法,而静态方法中无法调用非静态方法. 如果变量是静态变量我们就可以直接通过类名去访问这个变量,而非静态变量不可以直接通过类名来访问。 静态方法可以直接被调用，非静态方法需要实例化类对象之后，才可以通过对象来调用。 代码 package com.xiheya.oop.demo07; /** * @Author {xiheya} * @Date: 2022/03/13/ 20:44 * @Description */ public class Student { private static int age; //静态的变量 多线程中会用到 private double score; //非静态的变量 public void run(){ //非静态方法 go(); //非静态方法中可以直接调用静态方法 } public static void go(){ //静态方法 //run(); 而静态方法中无法调用非静态方法 } public static void main(String[] args) { Student s1 = new Student(); System.out.println(s1.score); //可以看到非静态变量需要实例化类对象之后，才可以通过对象来访问。 System.out.println(s1.age); System.out.println(Student.age); //如果变量是静态变量我们就可以直接通过类名去访问这个变量 //System.out.println(Student.score); 而非静态变量不可以直接通过类名来访问。 go(); //静态方法可以直接被调用 //run(); s1.run(); //非静态方法需要实例化类对象之后，才可以通过对象来调用。 } } 静态代码块在程序运行过程中，先执行父类，再执行子类。先执行静态代码块（且静态代码块只执行一次），然后再执行匿名代码块。最后再执行构造方法。 package com.xiheya.oop.demo07; /** * @Author {xiheya} * @Date: 2022/03/13/ 21:03 * @Description */ public class Person { { System.out.println(\"我是匿名代码块\"); } static { System.out.println(\"我是静态代码块\"); } public Person(){ System.out.println(\"我是构造方法\"); } public static void main(String[] args) { Person person = new Person(); } } 静态导入包（不常用）语法： import static java.lang.Math.random; import static java.lang.Math.PI; System.out.println(random()); System.out.println(PI); 当包被静态导入之后，在程序中就可以直接通过包内的方法名来调用这个方法。但是并不常用。 抽象类 abstract修饰符可以用来修饰方法也可以修饰类，如果修饰方法，那么该方法就是抽象方法；如果修饰类，那么该类就是抽象类。 抽象类中可以没有抽象方法，但是有抽象方法的类一定要声明为抽象类。 抽象类，不能用new关键字来创建对象，它是用来让子类继承的 抽象方法，只有方法的声明，没有方法的实现，它是用来让子类实现的。 子类继承抽象类，那么就必须要实现抽象类没有实现的抽象方法，否则该子类也要声明为抽象类。 抽象类存在的意义：抽象出来，提高开发效率。 package com.xiheya.oop.demo08; /** * @Author {xiheya} * @Date: 2022/03/13/ 21:27 * @Description */ //用abstract 关键字修饰的类叫做抽象类， public abstract class Action { //abstract 是一个约束，抽象方法 只有方法名字，没有方法的实现（没有方法体） 抽象方法由子类实现。 public abstract void doSomething(); //1.不能new这个抽象类，只能靠子类去实现 //2.抽象类中可以写普通方法 //3.抽象方法必须在抽象类中 //抽象的抽象：约束。 public Action() { } } 继承抽象类，就一定要实现抽象类里面的抽象方法。不然这个类就变成抽象类，然后让子类来实现。 package com.xiheya.oop.demo08; /** * @Author {xiheya} * @Date: 2022/03/13/ 22:05 * @Description */ //继承抽象类，就一定要实现抽象类里面的抽象方法 public class A extends Action{ @Override public void doSomething() { } } 接口 普通类：只有具体实现 抽象类：具体实现和规范（抽象方法）都有 接口：只有规范！自己无法写方法~专业的约束！约束和实现分离：面向接口编程~ 接口就是规范，定义的是一组规则，体现了现实世界中“如果你是……则必须能……”的思想。eg：如果你是天使，则必须能飞。如果你是汽车，则必须能跑。如果你是好人，则必须干掉坏人；如果你是坏人，则必须欺负好人。 接口的本质是契约，就像我们人间的法律一样，制定好后大家都遵守。 接口的精髓，是对对象的抽象，最能体现这一点的就是接口。为什么我们讨论设计模式都只针对具备了抽象能力的语言（比如c++、Java、c#等）就是因为设计模式所研究的，时间上就是如何合理的去抽象。 代码package com.xiheya.oop.demo09; /** * @Author {xiheya} * @Date: 2022/03/13/ 22:36 * @Description */ //抽象类是继承 extends // 类也可以实现接口 implements 接口 // 实现了接口的类，就必须重写接口中的方法 // 接口就间接的实现了多继承。 public class UserServiceImpl implements UserService,TimeService{ @Override public void timer() { } @Override public void add() { } @Override public void delete() { } @Override public void update() { } @Override public void query() { } } /* public interface TimeService { void timer(); } // interface 定义的关键字 ， 接口都需要有实现类 public interface UserService { //接口中所有属性类型 都是 public static final（但我们通常不在接口中定义属性） public static final int AGE = 99; //接口中所有定义其实默认都是抽象的 public abstract public abstract void add(); void delete(); void update(); void query(); } */ 作用 接口是一个约束 定义一些方法，让不同人实现。 方法的默认属性是 public abstract 常量的默认属性是public static final 接口不能被实例化~接口中没有构造方法~ implements可以实现多个接口 必须要重写接口中的方法 内部类定义内部类就是在一个类的内部再定义一个类，比如，A类中定义一个B类，那么B类相对于A类来说就称为内部类，而A类相对于B类来说就是外部类了。 分类成员内部类public class Application { public static void main(String[] args) { Outer outer = new Outer(); Outer.Inner inner = outer.new Inner(); inner.in(); inner.gerAge(); } } /* public class Outer { private int age = 10; public void out(){ System.out.println(\"I'm the outer\"); } public class Inner{ public void in(){ System.out.println(\"I'm the inner\"); } public void gerAge(){ System.out.println(age); } } } */ 内部类可以获得外部类的私有属性 要通过外部类来实例化内部类。 Outer outer = new Outer();Outer.Inner inner = outer.new Inner(); 静态内部类public class Application { public static void main(String[] args) { Outer outer = new Outer(); Outer.Inner inner = outer.new Inner(); inner.in(); inner.gerAge(); } } /* public class Outer { private int age = 10; public void out(){ System.out.println(\"I'm the outer\"); } public static class Inner1{ public void in(){ System.out.println(\"I'm the inner1\"); } } } */ 局部内部类public class Outer { public void method(){ //局部内部类 class Inner{ public void in(){ } } } } 匿名内部类public class Test { public static void main(String[] args) { //匿名内部类：没有名字初始化类，不用将实例保存到变量中 new Apple().eat(); } } class Apple{ public void eat(){ System.out.println(\"eat apple\"); } }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"},{"name":"Java面向对象","slug":"Java面向对象","permalink":"/tags/Java面向对象/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Java面向对象03","slug":"Java面向对象03","date":"2022-08-25T14:41:48.000Z","updated":"2022-08-25T15:03:14.353Z","comments":true,"path":"2022/08/25/javamianxiangduixiang03/","link":"","permalink":"/2022/08/25/javamianxiangduixiang03/","excerpt":"","text":"封装 该露的露，该藏的藏 我们程序设计要追求“高内聚，低耦合”。高内聚就是类的内部数据操作细节自己完成，不允许外部干涉；低耦合：仅暴露少量的方法给外部使用 封装（数据的隐藏） 通常，应禁止直接访问一个对象中数据的实际表示，而应通过操作接口来访问，这称为信息隐藏。 记住这句话：属性私有，get/set 封装的作用： 1.提高程序的安全性，保护数据 2.隐藏代码的实现细节 3.统一接口 4.系统可维护性增加了 代码： package com.xiheya.oop.demo04; /** * @Author {xiheya} * @Date: 2022/03/13/ 12:00 * @Description */ public class Student { // 属性私有 private String name; //姓名 private int id; //学号 private char sex; //性别 public Student() { } public Student(String name, int id, char sex) { this.name = name; this.id = id; this.sex = sex; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getId() { return id; } public void setId(int id) { this.id = id; } public char getSex() { return sex; } public void setSex(char sex) { this.sex = sex; } } /* public class Application { public static void main(String[] args) { Student Tom = new Student(); System.out.println(Tom.getName()); Tom.setName(\"Tom\"); System.out.println(Tom.getName()); System.out.println(Tom.getId()); Tom.setId(1234); System.out.println(Tom.getId()); } } */ 运行结果： 继承 继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模。 extends的意思是”扩展“。子类是父类的扩展。 Java中类只有单继承，没有多继承！ 继承是类和类之间的一种关系，除此之外，类和类之间的关系还有依赖、组合、聚合等。 继承关系的两个类，一个为子类（派生类）、一个为父类（基类）。子类继承父类，使用关键字extends来表示。 object类 super 方法重写 子类继承了父类，就会拥有父类的全部方法，前提是方法属性为在Java中所有类都默认直接或间接继承Object；快捷键：ctrl+H package com.xiheya.oop.demo05; /** * @Author {xiheya} * @Date: 2022/03/13/ 12:45 * @Description */ //在Java中所有类都默认直接或间接继承Object public class Person { public void speak(){ System.out.println(\"say some thing\"); } } /* //子类继承了父类，就会拥有父类的全部方法，前提是方法属性为 //快捷键：ctrl+H public class Teacher extends Person{ } public class Application { public static void main(String[] args) { // Student Tom = new Student(); // System.out.println(Tom.getName()); // Tom.setName(\"Tom\"); // System.out.println(Tom.getName()); // System.out.println(Tom.getId()); // Tom.setId(1234); // System.out.println(Tom.getId()); Teacher teacher = new Teacher(); teacher.speak(); } } */ 可以看到Teacher类没有speak方法，但是实例化的teacher对象却可以调用speak方法，原因就是Teacher继承了Person类，而Person类中定义了speak方法。 super关键字：super关键字可以在子类调用父类。 代码package com.xiheya.oop.demo05; /** * @Author {xiheya} * @Date: 2022/03/13/ 12:45 * @Description */ //在Java中所有类都默认直接或间接继承Object public class Person { public Person() { System.out.println(\"Person类的构造方法执行了\"); } public void speak(){ System.out.println(\"say some thing\"); } public void print(){ System.out.println(\"Person\"); } } /* //子类继承了父类，就会拥有父类的全部方法，前提是方法属性为 //快捷键：ctrl+H public class Teacher extends Person{ public Teacher() { System.out.println(\"Teache的构造方法执行了\"); } public void test(){ print(); this.print(); super.print(); } public void print(){ System.out.println(\"Teacher\"); } } public class Application { public static void main(String[] args) { // Student Tom = new Student(); // System.out.println(Tom.getName()); // Tom.setName(\"Tom\"); // System.out.println(Tom.getName()); // System.out.println(Tom.getId()); // Tom.setId(1234); // System.out.println(Tom.getId()); Teacher teacher = new Teacher(); teacher.speak(); } } */ 运行结果： 可以看到，当对象被实例化之后，会调用构造器方法，如果有父类则先调用父类的构造器方法。这是因为子类的构造方法中：默认添加了super();关键字，所以会先调用父类的构造器方法！同时，调用父类的构造器必须放在第一行。 super注意点 super调用父类的构造方法，必须在构造方法的第一个 super必须只能出现在子类的方法或者构造方法中 super和this不能同时调用构造方法 super与this的区别 代表的对象不同： this：本身调用者这个对象 super：代表父类对象的应用 前提： this：没有继承也可以使用 super：只能在继承条件才可以使用 构造方法： this();本类的构造 super():父类的构造 方法重写静态方法是类的方法，而非静态方法是对象的方法。 有static时，对象调用的是自身类的方法，没有static时，对象调用的是自身对象的方法。 静态方法和非静态方法差别很大 静态方法：方法的调用只和左边定义的数据类型有关 非静态：非静态方法才存在重写。 只有非静态的 public属性的方法才能被重写 package com.xiheya.oop.demo05; /** * @Author {xiheya} * @Date: 2022/03/13/ 15:27 * @Description */ public class B { public void test(){ System.out.println(\"b--->test\"); } } /* public class A extends B{ public void test(){ System.out.println(\"a--->test\"); } } public class Application { public static void main(String[] args) { A a = new A(); B b = new A(); a.test(); b.test(); } } */ 代码package com.xiheya.oop.demo05; /** * @Author {xiheya} * @Date: 2022/03/13/ 15:27 * @Description */ public class B { public void test(){ System.out.println(\"b--->test\"); } } /* public class A extends B{ public void test(){ System.out.println(\"a--->test\"); } } public class Application { public static void main(String[] args) { A a = new A(); B b = new A(); a.test(); b.test(); } } */ 运行结果 笔记重写：需要有继承关系，子类重写父类的方法！ 方法名必须相同 参数列表必须相同 修饰符：范围可以扩大. public&gt;protected&gt;default&gt;private 抛出的异常：范围可以被缩小，但不能扩大。eg父类抛出的异常为：Exception，那么子类抛出的异常范围就需要比Exception要小。可以抛出为：ClassNotFoundException 重写：子类的方法和父类必须要一致，方法体不同。 为什么要重写： 父类的功能，子类不一定需要，或者不一定满足 多态 动态编译：类型”可扩展性更强 多态即同一个方法可以根据发送对象的不同而采用多种不同的行为方式。 一个对象的实际类型是确定的，但可以指向对象的引用的类型有很多 多态存在的条件 有继承关系 子类重写父类方法 父类引用指向子类对象 注意：多态是方法的多态，属性没有多态 instanceof 代码package com.xiheya.oop.demo06; /** * @Author {xiheya} * @Date: 2022/03/13/ 15:59 * @Description */ public class Person { public void run(){ System.out.println(\"Person run\"); } } /* public class Student extends Person{ @Override public void run() { System.out.println(\"Student run\"); } public void eat(){ System.out.println(\"Student eat\"); } } public class Application { public static void main(String[] args) { //一个对象的实际类型是确定的 // 可以指向的引用类型就不确了 父类的引用可以指向子类 // Student 能调用的方法都是自己的，或者继承父类的、 Student s1 = new Student(); //Person 父类型，可以指向子类，但是不能调用子类独有的方法 Person s2 = new Student(); Object s3 = new Student(); //对象执行哪些方法，主要看对象左边的类型，和右边关系不大 // 子类重写了父类的方法，则执行子类的方法。 s1.run(); s2.run(); ((Student)s2).eat(); s1.eat(); } } */ 运行结果 注意事项 多态是方法的多态；属性没有多态。 父类和子类，有联系 （类型转换异常–ClassCastException） 存在条件：继承关系，方法需要重写，父类引用指向子类对象。Father f1 = new Son(); 哪些方法不能重写？ static方法，static代码块属于类，对象被创建时一同被执行 final：常量 被final修饰的方法不能被重写，被final修饰的类不能被继承；被final修饰的变量一经赋值后续不能更改。 private方法： 私有属性不能被继承 instanceof关键字代码：package com.xiheya.oop; import com.xiheya.oop.demo06.Teacher; import com.xiheya.oop.demo06.Student; import com.xiheya.oop.demo06.Person; /** * @Author {xiheya} * @Date: 2022/03/13/ 11:59 * @Description */ public class Application { public static void main(String[] args) { Student student = new Student(); Person person = new Student(); Object object = new Student(); //X instanceof Y:能不能编译通过主要看X和Y是否存在父子关系。 System.out.println(object instanceof Student); //true System.out.println(object instanceof Person); //true System.out.println(object instanceof Object); //true System.out.println(object instanceof Teacher); //false System.out.println(object instanceof String); //false System.out.println(\"========================\"); System.out.println(person instanceof Student); //true System.out.println(person instanceof Person); //true System.out.println(person instanceof Object); //true System.out.println(person instanceof Teacher); //false //System.out.println(person instanceof String); //编译报错 System.out.println(\"========================\"); System.out.println(student instanceof Student); //true System.out.println(student instanceof Person); //true System.out.println(student instanceof Object); //true //System.out.println(student instanceof Teacher); //编译报错 //System.out.println(student instanceof String); //编译报错 //类型之间的转换 父-------》子 // 高-------------------低（强制转换）。 // Person obj = new Student(); // //student.go();报错： 因为Person类中没有go方法。需要将Person类型强制转换为Student类型 // ((Student) obj).go(); // // //类型之间的转换 子-------》父 // Student student = new Student(); // //由Student类型转换为他的父类Person类型可以直接转换，但是可能会丢失一些自己本来的方法。 // Person person = student; } } /* 1.父类引用指向子类的对象 2.把子类转换为父类：向上转型：（自动转换） 3.把父类转换为子类：向下转型：（强制转换） 4.方便方法的调用，减少代码重复率，简洁 */ 运行结果 强制转换 父类引用指向子类的对象 把子类转换为父类：向上转型：（自动转换） 把父类转换为子类：向下转型：（强制转换） 方便方法的调用，减少代码重复率，简洁 由Student类型转换为他的父类Person类型可以直接转换，但是可能会丢失一些自己本来的方法。 student.go();报错： 因为Person类中没有go方法。需要将Person类型强制转换为Student类型 类型之间的转换高——————-低（强制转换） 低——————-高（自动转换） 代码： public class Application { public static void main(String[] args) { //类型之间的转换 父-------》子 // 高-------------------低（强制转换）。 Person obj = new Student(); //student.go();报错： 因为Person类中没有go方法。需要将Person类型强制转换为Student类型 ((Student) obj).go(); //类型之间的转换 子-------》父 Student student = new Student(); //由Student类型转换为他的父类Person类型可以直接转换，但是可能会丢失一些自己本来的方法。 Person person = student; } } /* 1.父类引用指向子类的对象 2.把子类转换为父类：向上转型：（自动转换） 3.把父类转换为子类：向下转型：（强制转换） 4.方便方法的调用，减少代码重复率，简洁 */","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"},{"name":"Java面向对象","slug":"Java面向对象","permalink":"/tags/Java面向对象/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Java面向对象02","slug":"Java面向对象02","date":"2022-08-25T14:41:45.000Z","updated":"2022-08-25T15:03:11.082Z","comments":true,"path":"2022/08/25/javamianxiangduixiang02/","link":"","permalink":"/2022/08/25/javamianxiangduixiang02/","excerpt":"","text":"构造器 类中的构造器也称为构造方法，是在进行创建对象的时候必须要调用的。并且构造器有以下两个特点： 1.必须和类的名字相同 2.必须没有返回类型，也不能写void 代码： package com.xiheya.oop.demo02; /** * @Author {xiheya} * @Date: 2022/03/12/ 22:50 * @Description */ //学生类 public class Student { //一个类即使什么都不写，也会存在一个构造方法 // 显示的定义构造期。 // 属性：字段 String name; int age; // 方法 // 实例化初始值 // 1.使用new关键字，实质上是调用构造器 // 2.构造器一般用来初始化值 . public Student(){ } // 一旦定义了有参构造，无参构造就必须显示定义 public Student(String name,int age){ this.setName(name); this.setAge(age); } public void study(){ System.out.println(this.name + \" is study\"); } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } } /* //一个项目应该只存在一个main方法 public class Application { public static void main(String[] args) { //类是一个抽象的事物，我们在使用它时要先实例化 Student student = new Student(); student.study(); Student Tom = new Student(\"Tom\",3); Tom.study(); } } 构造器： 1.和类名相同 2.没有返回值 作用： 1.new本质在调用构造器 2.初始化对象的值 注意点: 1.定义有参构造后，如果想使用无参构造，无参构造一定要显式定义 快捷键：Alt + Insert */ 构造器： 1.和类名相同 2.没有返回值 作用： 1.new本质在调用构造器 2.初始化对象的值 注意点: 1.定义有参构造后，如果想使用无参构造，无参构造一定要显式定义 快捷键：Alt + Insert 创建对象内存分析代码： package com.xiheya.oop.demo03; /** * @Author {xiheya} * @Date: 2022/03/12/ 23:57 * @Description */ public class Pet { String name; int age; public void shout(){ System.out.println(\"wow wow wow\"); } } /* public class Application { public static void main(String[] args) { Pet dog = new Pet(); dog.name = \"旺财\"; dog.age = 3; dog .shout(); Pet cat = new Pet(); } } */ 内存分析 先将Application类中的main()方法以及常量池中的旺财，加载到方法区。 将main()方法压入栈底 Pet dog = new Pet（实例化一个dog对象）时，将Pet类及其name、age属性和shout方法加载到方法区当中。 实例化dog对象时，会在栈当中引用dog变量名并指向堆中正在初始化的Pet类，而堆中的Pet又会指向方法去中的Pet。 Pet cat= new Pet（实例化一个cat对象）时，将Pet类及其name、age属性和shout方法加载到方法区当中。 实例化cat对象时，会在栈当中引用dog变量名并指向堆中正在初始化的Pet类，而堆中的Pet又会指向方法去中的Pet。 图解： 小结 类与对象 类是一个模板—抽象；对象是一个具体的实例 方法 方法的定义及调用 对应的应用 引用类型：基本类型（8），对象是通过引用来操作的：栈—-&gt;堆（地址） 属性：字段Field 成员变量 默认初始化： 数字 ： 0 0.0 char： u0000 boolean：false 引用：null 属性的定义 修饰符 + 属性类型 + 属性名 = 属性值 对象的创建和使用 必须使用new 关键字创造对象，构造器Person xiheya = new Person(); 对象的属性 xiheya.name 对象的方法 xiheya.sleep(); 类 静态的属性 属性 动态的行为 方法","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"},{"name":"Java面向对象","slug":"Java面向对象","permalink":"/tags/Java面向对象/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Java面向对象01","slug":"Java面向对象01","date":"2022-08-25T14:41:42.000Z","updated":"2022-08-25T15:03:08.479Z","comments":true,"path":"2022/08/25/javamianxiangduixiang01/","link":"","permalink":"/2022/08/25/javamianxiangduixiang01/","excerpt":"","text":"面向过程&amp; 面向对象面向过程思想—&gt;自上而下面向对象就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。 步骤清晰简单，第一步做什么，第二步做什么…… 面向过程适合处理一些较为简单的问题 面向对象思想—&gt;自下而上面向对象就是根据类创建对象，每个对象都有自己的属性和方法，而这些属性和方法都是围绕对象服务的，你会发现用到的属性和方法都是对象。 物以类聚，分类的思维模式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独思考。最后，才对某个分类下的细节进行面向过程的思索。 面向对象适合处理复杂的问题，适合处理需要多人协作的问题。 对于描述复杂的事物，为了从宏观上把握，从整体上合理分析，我们需要使用面向对象的思路来分析整个系统。但是，具体到微观操作，仍然需要面向过程的思路去处理。 什么是面向对象 面向对象编程（Object_Oriented Programming， OOP） 面向对象编程的本质就是：以类的方式组织代码，以对象的形式（封装）数据 抽象 —&gt;将有共同特征的物体抽象成一个类，比如泰迪、哈士奇、金毛，他们都有个共同的特征，那就是他们都是狗。 三大特征 封装 继承 多态 从认识论的角度考虑：先有对象后有类。对象，是具体的事物。类，是抽象的，是对对象的抽象 从代码运行的角度考虑，是先有类后有对象。类是对象的模板。 回顾方法及加深方法的定义 修饰符 返回类型 break：（跳出switch，结束循环） 和 return（结束方法，返回一个结果）的区别 方法名：注意规范就可以（首字母小写驼峰法），见名知意 参数列表：（参数类型，参数名）…… 异常抛出： 方法的调用:递归 静态方法 非静态方法 package com.xiheya.oop; /** * @Author {xiheya} * @Date: 2022/03/12/ 22:30 * @Description */ public class Demo02 { public static void main(String[] args) { Demo02 demo02 = new Demo02(); int sum = demo02.add(1, 2); //实例化对象demo02后，才可以调用非静态方法add System.out.println(sum); System.out.println(add(1, 2, 3)); //而静态方法add则可以直接调用 } public static int add(int a,int b, int c){ //静态方法，main方法中可以直接调用。 return a+b+c; } public int add(int a,int b){ //非静态方法，调用的话需要实例化对象后才能调用。 return a+b; } } 形参和实参 值传递和引用传递 代码： package com.xiheya.oop; /** * @Author {xiheya} * @Date: 2022/03/12/ 21:52 * @Description */ // 值传递和引用传递 public class Demo01 { public static void main(String[] args) { int a = 1; System.out.println(a); change(a); //调用change方法时，传给chang的只是a的值，change方法中对a的一系列操作均不会对main中的a产生影响 System.out.println(a); //可以看到尽管在change方法中对a进行了赋值操作，但仍然没有改变a的值。这就是Java的值传递。 Person person = new Person(); //实例化一个类，new一个Person类。 System.out.println(person.name); changeName(person); //由于传递给changeName方法的是一个类对象，方法对person.name 的修改是对Person类中 name的修改，所以是一定可以修改成功的， System.out.println(person.name); //这就是引用传递（实质上还是值传递） } public static void change(int a){ a = 10; } public static void changeName(Person person){ //person是一个对象，指向的是Person这个类，这是一个具体的人，可以改变属性 person.name = \"xiheya\"; } } class Person{ String name; } 运行结果： this关键字 类与对象的关系 类是一种抽象的数据类型，它是对某一类事物整体描述/定义，但是并不能代表某一个具体的事物。 动物、植物、手机、电脑 Person类、Pet类、Car类等，这些类都是用来描述/定义某一类具体的事物应该具备的特点和行为 对象是抽象概念的具体实例 eg：张三就是人的一个具体实例，而张三家的旺财就是狗的一个具体实例 能够体现出特点，展现出功能的是具体的实例，而不是一个抽象的概念。 创建和初始化对象 使用new关键字创建对象 使用new关键字创建的时候，除了分配内存空间之外，还会给创建好的对象进行默认的初始化以及对类中构造器的调用。 类中的构造器也称为构造方法，是在进行创建对象的时候必须要调用的。并且构造器有以下两个特点： 1.必须和类的名字相同 2.必须没有返回类型，也不能写void 构造器方法必须掌握","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"},{"name":"Java面向对象","slug":"Java面向对象","permalink":"/tags/Java面向对象/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Java数组03","slug":"Java数组03","date":"2022-08-25T14:41:24.000Z","updated":"2022-08-25T15:02:49.895Z","comments":true,"path":"2022/08/25/javashuzu03/","link":"","permalink":"/2022/08/25/javashuzu03/","excerpt":"","text":"Arrays类 数组的工具类java.util.Arrays 由于数组对象本身并没有什么方法可以供我们调用，但API中提供了一个工具类Arrays供我们使用，从而可以对数据进行一些基本操作。 查看JDK帮助文档 Arrays类中的方法都是static修饰的静态方法，在使用的时候可以直接使用类名进行调用，而”不用“使用对象来调用（注意：是”不用”而不是“不能”） 具有以下常用功能： 给数组赋值：通过fill方法。 对数组排序：通过sort方法，按升序 比较数组：通过equals方法比较数组中元素值是否相等 查找数组元素：通过binarySearch方法能对排列好的数组进行二分查找法操作 代码实现： package com.xiheya.Array; import java.util.Arrays; /** * @Author {xiheya} * @Date: 2022/03/12/ 16:19 * @Description */ public class ArrayDemo05 { public static void main(String[] args) { int[] a = {1,2,3,4,65,98,54,21,0}; System.out.println(Arrays.toString(a)); //Arrays 里的toString方法 Arrays.sort(a); //sort，将a中的数据从小到大排列 System.out.println(Arrays.toString(a)); } } 运行结果： 冒泡排序 冒泡排序是最出名的算法之一，总共有八大排序！ package com.xiheya.Array; import java.util.Arrays; /** * @Author {xiheya} * @Date: 2022/03/12/ 16:32 * @Description */ public class ArrayDemo06 { public static void main(String[] args) { int[] a = {1,6,5,3,2,9}; System.out.println(Arrays.toString(a)); sort(a); System.out.println(Arrays.toString(a)); } //冒泡排序： // 1.比较两个相邻的数，如果第一个数比第二个数大，则交换他们的位置。 // 2.每一次排序都会产生一个最大或最小的数字； // 3.下一轮则可以少一次排序 // 4.依次循环直到结束 public static void sort(int[] a){ int temp = 0; for (int i = 0; i &lt; a.length-1; i++) { for (int j = 0; j &lt; a.length-i-1; j++){ if (a[j] > a[j+1]){ temp = a[j]; a[j] = a[j+1]; a[j+1] = temp; } } } } } 运行结果： 稀疏数组 需求：编写五子棋游戏中，有存盘退出和续上盘的功能。 介绍：当一个数组中大部分元素为0，或者为同一值的数组时，可以使用稀疏数组来保存该数组。 稀疏数组的处理方式是： 记录数组一共有几行几列，有多少个不同值 把具有不同值的元素和行列及值记录在一个小规模的数组中，从而缩小程序的规模 稀疏数组与原数组图示： 设计一个程序实现 稀疏数组与普通数组 的互换 代码： package com.xiheya.Array; /** * @Author {xiheya} * @Date: 2022/03/12/ 17:39 * @Description */ public class ArrayDemo07 { public static void main(String[] args) { int[][] array = new int[11][11]; array[2][3] = 2; array[1][4] = 1; printArray(array); //打印原数组 int[][] array1 = toArray(array); //将原数组转换为稀疏数组 printArray(array1); //打印转换好的稀疏数组 int[][] restore = restore(array1); //将稀疏数组再转换为普通数组 printArray(restore); //打印转换完成后的数组 } public static void printArray(int[][] array){ //通过for_each遍历方法，打印数组 System.out.println(\"start to print the array:\"); for (int[] ints : array) { //for_each遍历外层 System.out.print(\"[\"); for (int anInt : ints) { //for_each遍历内层 System.out.print(anInt + \"\\t\"); } System.out.print(\"]\"); System.out.println(); } } public static int[][] toArray(int[][] a){ //将普通数组转换为稀疏数组的方法 int sum = 0; //用sum来统计，不为0元素的个数，sum为稀疏数组的行号。即int[][] temp = new int[sum+1][3]; for (int[] ints : a) { for (int anInt : ints) { if (anInt != 0){ sum++; } } } int[][] temp = new int[sum+1][3]; //统计完sum声明并创建稀疏数组temp temp[0][0] = a.length; //temp[0][0] 存放行数 temp[0][1] = a[0].length; //temp[0][1] 存放列数 temp[0][2] = sum; //temp[0][2] 存放数组内有效数据个数 int tempnum = 1; //稀疏数组行号tempnum for (int i = 0; i &lt; a.length; i++) { //遍历普通数组，当遍历到普通数字内有效数字时 for (int j = 0; j &lt; a[i].length; j++) { if (a[i][j] != 0){ temp[tempnum][0] = i; //将原普通数组行号赋值给temp[tempnum][0] temp[tempnum][1] = j; //将原普通数组行号赋值给temp[tempnum][1] temp[tempnum][2] = a[i][j]; //将原普通数组第i行j列的数据 赋值给temp[tempnum][2] tempnum++; //装载完成后，稀疏数组行号 tempnum 自增1 } } } return temp; } public static int[][] restore (int[][] array){ //将稀疏数组还原为普通数组的方法 int[][] result = new int[array[0][0]][array[0][1]]; //声明并创建还原后的数组：result for (int i = 1; i &lt; array.length ; i++) { //遍历稀疏数组，取出原普通数组的行号和列号 result[array[i][0]][array[i][1]] = array[i][2]; //array[i][0]代表原数组有效数组的行号、array[i][1]代表其列号，遍历到这里时，将原数组第array[i][0]行第array[i][1]列的数据array[i][2]赋值回去。 } return result; //返回还原完成后的普通数组。 } } 运行结果：","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"},{"name":"Java数组","slug":"Java数组","permalink":"/tags/Java数组/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Java数组02","slug":"Java数组02","date":"2022-08-25T14:41:21.000Z","updated":"2022-08-25T15:02:42.322Z","comments":true,"path":"2022/08/25/javashuzu02/","link":"","permalink":"/2022/08/25/javashuzu02/","excerpt":"","text":"内存分析 Java内存分析 数组的声明在栈当中，创建空间及赋值操作在堆中。 三种初始化静态初始化int[] a = {1,2,3}; Man[] mans = {new Man(1,1),new Man(2,2)}; 动态初始化int[] a = new int[5]; a[0] = 1; a[1] = 2; …… 数组的默认初始化 数组是引用类型，他的元素相当于类的实例变量，因此数组一经分配空间，其中的每个元素也被按照实例变量同样的方式被隐式初始化。 代码： package com.xiheya.Array; /** * @Author {xiheya} * @Date: 2022/03/12/ 10:45 * @Description */ public class ArrayDemo02 { public static void main(String[] args) { //静态初始化 int[] a = {1,2,3,4,5}; System.out.println(a[0]); //动态初始化,包含默认初始化 int[] b = new int[2]; b[0] = 10; System.out.println(b[0]); System.out.println(b[1]); } } 运行截图： 数组边界 下标的合法区间：[0,length-1],如果越界就会报错 public static void main(String[] args){ int[] a = new int[2]; System.out.println(a[2]); } ArrayIndexOutOfBoundsException:数组下标越界异常 小结 数组是相同数据类型（数据类型可以为任意类型）的有序集合 数组也是对象，数组元素相当于对象的成员变量 数组长的确定的，不可变的。如果越界，则报：ArrayIndexOutOfBounds 数组的使用简单for循环package com.xiheya.Array; /** * @Author {xiheya} * @Date: 2022/03/12/ 11:12 * @Description */ public class ArrayDemo03 { public static void main(String[] args) { int[] a = {1,2,3,4,5}; for (int i = 0; i &lt; a.length; i++) { System.out.println(a[i]); } } } For-Each循环package com.xiheya.Array; /** * @Author {xiheya} * @Date: 2022/03/12/ 11:12 * @Description */ public class ArrayDemo03 { public static void main(String[] args) { int[] a = {1,2,3,4,5}; for (int i : a) { System.out.println(i); } } } 数组作方法入参package com.xiheya.Array; /** * @Author {xiheya} * @Date: 2022/03/12/ 11:12 * @Description */ public class ArrayDemo03 { public static void main(String[] args) { int[] a = {1,2,3,4,5}; // for (int i = 0; i &lt; a.length; i++) { // System.out.println(a[i]); // } // for (int i : a) { // System.out.println(i); // } printArray(a); int[] result = reverseArray(a); System.out.println(\"\\n=================\"); printArray(result); } public static void printArray(int[] a){ //将数组作为参数传入方法中，然后打印数组 for (int i = 0; i &lt; a.length; i++) { System.out.print(a[i] + \" \"); } } public static int[] reverseArray(int[] a){ //将数组作为方法返回值，反转数组后返回结果数组。 int[] result = new int[a.length]; for (int i = 0,j = result.length-1 ; i &lt; a.length; i++,j--) { result[i] = a[j]; } return result; } } 数组作返回值package com.xiheya.Array; /** * @Author {xiheya} * @Date: 2022/03/12/ 11:12 * @Description */ public class ArrayDemo03 { public static void main(String[] args) { int[] a = {1,2,3,4,5}; // for (int i = 0; i &lt; a.length; i++) { // System.out.println(a[i]); // } // for (int i : a) { // System.out.println(i); // } printArray(a); int[] result = reverseArray(a); System.out.println(\"\\n=================\"); printArray(result); } public static void printArray(int[] a){ //将数组作为参数传入方法中，然后打印数组 for (int i = 0; i &lt; a.length; i++) { System.out.print(a[i] + \" \"); } } public static int[] reverseArray(int[] a){ //将数组作为方法返回值，反转数组后返回结果数组。 int[] result = new int[a.length]; for (int i = 0,j = result.length-1 ; i &lt; a.length; i++,j--) { result[i] = a[j]; } return result; } } 运行结果： 多维数组 多维数组可以看成是数组的数组（套娃），比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组。 二维数组 语法： int a[][] = new int[2][5] //声明并创建一个两行五列的数组 解析：二维数组a可以看一个两行五列的数组 代码示例： package com.xiheya.Array; /** * @Author {xiheya} * @Date: 2022/03/12/ 11:43 * @Description */ public class ArrayDemo04 { public static void main(String[] args) { /** * array: * 1 2 * 3 4 * 5 6 * 7 8 */ int[][] array = {{1,2}, {3,4},{5,6},{7,8}}; for (int i = 0; i &lt; array.length; i++) { System.out.println(\"\\nprint array[\" + i + \"],nums\"); for (int j = 0; j &lt; array[i].length; j++) { System.out.print(array[i][j]+\" \"); } } } } 运行结果：","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"},{"name":"Java数组","slug":"Java数组","permalink":"/tags/Java数组/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Java数组01","slug":"Java数组01","date":"2022-08-25T14:41:17.000Z","updated":"2022-08-25T15:02:35.415Z","comments":true,"path":"2022/08/25/javashuzu01/","link":"","permalink":"/2022/08/25/javashuzu01/","excerpt":"","text":"数组的定义 数组是相同类型数据的有序集合 数组描述的是相同类型的若干个数据，按照一定先后次序排列组合而成。 其中，每一个数据称作一个数组元素，每个数组元素可以通过一个下标来访问它。 数组声明创建 首先必须声明数组变量，才能再程序中使用数组。语法如下： dataType[] arrayRefVar; //首选方法 dataType arrayRefVar[]; //效果相同，但不是首选方法 Java语言使用new操作符来创建数组，语法如下： dataType [] arrayRefVar = new dataType[arraySize]; 数组的元素是通过索引访问的，数组索引从0开始。 获取数组长度：arrays.length package com.xiheya.Array; /** * @Author {xiheya} * @Date: 2022/03/12/ 10:21 * @Description */ public class Demo01 { public static void main(String[] args) { int[] nums; //1.声明一个数组 nums = new int[10]; //2.给数组开辟空间，创建一个数组 int[] numrs = new int[10]; //直接声明数组并创建 } } 数组的四个基本特点 其长度是确定的。数组一旦被创建，它的大小就是不可以改变的。 其元素必须是相同类型，不允许出现混合类型。 数组中的元素可以是任何数据类型，包括基本类型和引用类型。 数组变量属引用类型，数组也可以看成是对象，数组中每个元素相当于该对象的成员变量。 数组本身就是对象，Java中对象是在堆中的，因此 数组无论保存原始类型还是其他对象类型，数组对象本身是在堆中的","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"},{"name":"Java数组","slug":"Java数组","permalink":"/tags/Java数组/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Java方法","slug":"Java方法","date":"2022-08-25T14:41:09.000Z","updated":"2022-08-25T15:04:32.722Z","comments":true,"path":"2022/08/25/javafangfa/","link":"","permalink":"/2022/08/25/javafangfa/","excerpt":"","text":"方法定义 Java方法是语句的集合，它们在一起执行一个功能 方法是解决一类问题的步骤的有序组合 方法包含于类或对象当中 方法在程序中被创建，在其他地方被引用 设计方法的原则 方法的本意是功能块，就是实现某个功能的语句块的集合。我们设计方法的时候，最好保持方法的原子性，就是一个方法只完成一个功能，这样利于我们后期的扩展 方法的命名规则：首字母小写，后面是驼峰命名规则。 设计一个方法：实现简单的两个数的加法： package com.xiheya.Method; /** * @Author {xiheya} * @Date: 2022/03/11/ 16:23 * @Description */ public class Demo01 { public static void main(String[] args) { System.out.println(add(1,2)); //方法的调用 } public static int add(int a , int b){ //方法的定义 return a+b; } } Java的方法类似于其他语言的函数，是一段用来完成特定功能的代码片段，一般情况下，定义一个方法包含以下语句： 方法包含一个方法头和一个方法体下面是一个方法的所有部分 修饰符：修饰符是可选的，它告诉编译器该如何调用该方法。定义了该方法的访问类型 返回值类型：方法可能会返回值，returnValueType是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType是关键字void。 方法名：是方法的实际名称。方法名和参数表共同构成方法签名。 参数类型： 参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数 形式参数：在方法被调用时用于接收外界输入的数据。 实参：调用方法时实际传给方法的数据。 方法体：方法体包含具体的语句，定义该方法功能 修饰符 返回值类型 方法名(参数类型 参数名){ …… 方法体 …… return 返回值; } 小tips：值传递和应用传递 Java为值传递 值传递(pass by value)：在调用函数时，将实际参数复制一份传递到函数中，这样在函数中对参数进行修改，就不会影响到原来的实际参数； 引用传递(pass by reference):在调用函数时，将实际参数的地址直接传递到函数中。这样在函数中对参数进行的修改，就会影响到实际参数； 方法的重载 重载就是在一个类中，有相同的函数名称，但形参不同的函数。 方法重载的规则 方法名称必须相同 参数列表必须不同（个数不同、或类型不同、参数排列顺序不同等） 方法的返回类型可以相同也可以不相同 仅仅返回类型不同不足以成为方法的重载。 实现理论： 方法名称相同时，编译器会根据调用方法的参数个数，参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错。 实现max()函数的重载 package com.xiheya.Method; /** * @Author {xiheya} * @Date: 2022/03/11/ 21:56 * @Description */ public class Demo02 { public static void main(String[] args) { int max = max(10,20); System.out.println(max); double dmax = max(20.0,30.0); System.out.println(dmax); } public static int max(int a, int b){ return a > b ? a : b; //三目运算符：进行判断，a大于b吗？如果大于返回a，否则返回b。 } public static double max(double a, double b){ // 方法重载，方法名一样均为max，但是返回值与参数类型不一样，所以可以构成重载 return a > b ? a : b; //三目运算符：进行判断，a大于b吗？如果大于返回a，否则返回b。 } } 运行结果： 命令行传参 有时候你希望运行一个程序时候再给他传递消息，这要靠传递命令行参数来给main()函数实现 通过在运行时使用命令行给main()函数来实现。 可变参数 JDK 1.5开始，Java支持传递同类型的可变参数给一个方法。 在方法声明中，在指定参数类型后加一个省略号（……） 一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明 设计一个程序计算出可变字长数组的最大值 代码： package com.xiheya.Method; /** * @Author {xiheya} * @Date: 2022/03/11/ 22:16 * @Description */ public class Demo04 { //可变参数 public static void main(String[] args) { double [] test1 = {10,20,30,40}; Demo04 demo04 = new Demo04(); demo04.printMax(10.0,20.0,30.0); demo04.printMax(test1); } public static void printMax(double... i){ if (i.length == 0){ System.out.println(\"error!!the length is 0\"); return; } double result = i[0]; for (int j = 0; j &lt; i.length; j++) { if (i[j] > result){ result = i[j]; } } System.out.println(\"the max number is \" + result); } } 运行结果： 递归 A方法可以调用B方法，这是很常见的。 而递归就是：A方法调用A方法，自己调用自己 利用递归可以用简单的程序解决一些复杂的问题。它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可以描述出解题过程所需要的多次重复计算，大大减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合 递归结构包括两个部分： 递归头：什么时候不调用自身方法。如果没有头，会陷入死循环 递归体：什么时候需要调用自身方法。 设计一个程序计算递归 代码： package com.xiheya.Method; /** * @Author {xiheya} * @Date: 2022/03/11/ 22:37 * @Description */ public class Demo03 { public static void main(String[] args) { System.out.println(function(3)); //打印出6的阶乘 } public static int function(int n){ //计算阶乘的方法 if (n == 1){ return 1; }else { return n*function(n-1); } } }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"},{"name":"Java方法","slug":"Java方法","permalink":"/tags/Java方法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Java流程控制03","slug":"Java流程控制03","date":"2022-08-25T14:41:01.000Z","updated":"2022-08-25T15:03:54.064Z","comments":true,"path":"2022/08/25/javaliuchengkongzhi03/","link":"","permalink":"/2022/08/25/javaliuchengkongzhi03/","excerpt":"","text":"循环结构while 循环 while 是最基本的循环 语法 while(布尔表达式){ //循环内容 } 只要布尔表达式为true，则循环一直执行下去 我们大多数情况下会让循环停止下来，我们需要一个让表达式失效的方式来结束循环 少部分情况循环需要一直执行，比如服务器的请求响应监听 循环条件一直为true就会造成无限循环【死循环】，正常业务中，应当避免死循环。它会影响程序性能或者造成程序卡死崩溃 设计一个程序计算1+2+3+4+5+……+100； 代码： package com.xiheya.struct; /** * @Author {xiheya} * @Date: 2022/03/08/ 17:44 * @Description */ public class WhileDemo01 { public static void main(String[] args) { int i = 0; int total = 0; while( i &lt; 100) { i++; total += i ; } System.out.println(total); } } do …… while循环 对于while语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件时 也至少执行一次。 do ……while循环 和while循环相似，不同的是，多……while循环至少会执行一次。 语法 do{ //代码语句 }while(布尔表达式); while和do-While的区别： while先判断后执行，dowhile是先执行后判断！ Do……while总是保证循环体会被至少执行一次！这是他们的主要差别 代码： package com.xiheya.struct; /** * @Author {xiheya} * @Date: 2022/03/08/ 17:56 * @Description */ public class DoWhileDemo01 { public static void main(String[] args) { int i = 0; int total = 0; do{ i++; total += i; }while(i &lt; 100); System.out.println(total); } } for循环 虽然所有循环结构都可以用while或者do……while表示，但Java提供了另一种语句—for循环，使一些循环结构变得更加简单。 for循环语句是支持迭代的一种通用结构，是最有效，最灵活的循环 for循环执行的次数在执行前就确定。语法格式如下： for(初始化; 布尔表达式 ; 更新){ //代码语句 } 设计一个程序计算出0-100的奇数和与偶数和 代码： package com.xiheya.struct; /** * @Author {xiheya} * @Date: 2022/03/08/ 22:27 * @Description */ public class ForDemo01 { public static void main(String[] args) { int oddtotal = 0;//奇数和 int eventotal = 0;//偶数和 for (int i = 0; i &lt;= 100; i++) { if (i%2 == 0){ eventotal += i; }else { oddtotal += i; } } System.out.println(\"偶数和：\\t\"+eventotal); System.out.println(\"奇数和: \\t\"+oddtotal); } } 运行截图 设计一个程序输出1-1000之间能被5整除的数，每行输出三个 代码： package com.xiheya.struct; /** * @Author {xiheya} * @Date: 2022/03/08/ 22:27 * @Description */ public class ForDemo01 { public static void main(String[] args) { int oddtotal = 0;//奇数和 int eventotal = 0;//偶数和 for (int i = 0; i &lt;= 100; i++) { if (i%2 == 0){ eventotal += i; }else { oddtotal += i; } } System.out.println(\"偶数和：\\t\"+eventotal); System.out.println(\"奇数和: \\t\"+oddtotal); for (int i = 0; i &lt;= 1000; i++) { if ((i%5) == 0){ //对 System.out.print(i+\"\\t\"); } if (((i+1) % (5*3)) == 0){ System.out.print(\"\\n\"); } } } } 设计一个程序打印出99乘法表 程序 package com.xiheya.struct; /** * @Author {xiheya} * @Date: 2022/03/09/ 16:56 * @Description */ public class ForDemo02 { public static void main(String[] args) { for (int i = 1; i &lt;= 9; i++) { for (int j = 1; j &lt;= i; j++) { //行由i控制，第i行输出i个依次类推 System.out.print( j + \"*\" + i + \"=\" + i*j + \"\\t\"); } System.out.println(); //输出完一行就换一次行 } } } 运行结果 增强for循环 Java5引入了一种主要用于数组或集合的增强for循环。 增强for循环语法格式 for(声明语句:表达式){ //代码语句 } 声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限制在循环语句块，其值与此时数组元素的值相等。 表达式：表达式是要访问的数组名，或者是返回值为数组的方法。 代码示例：简单的遍历代码 package com.xiheya.struct; /** * @Author {xiheya} * @Date: 2022/03/09/ 18:56 * @Description */ public class ForDemo03 { public static void main(String[] args) { int [] numbers = {10,20,30,40,50}; for (int x : numbers){ System.out.println(x); }; } } break 和 continue break在任何循环语句的主体部分，均可用break控制循环的流程。break用于强行退出循环，不执行循环中剩余的语句。（break语句也可以在switch语句中使用） 示例： package com.xiheya.struct; /** * @Author {xiheya} * @Date: 2022/03/09/ 19:13 * @Description */ public class Break { public static void main(String[] args) { for (int i = 1; i &lt; 100; i++) { if (i == 30){ System.out.println(); break; //break;程序运行到这里的时候就会跳出循环，但是还会执行循环后面的语句 } System.out.println(i); } System.out.println(\"我还可以继续运行\"); //跳出循环后程序还是会继续运行 } } 输出结果：当i自增到30时，会跳出这个for循环，但是程序还会继续往下运行。 continue语句用在循环语句体中，用于终止某次循环过程，即跳过循环体中尚未执行的语句，接着进行下一次是否执行循环的判定。 示例 package com.xiheya.struct; /** * @Author {xiheya} * @Date: 2022/03/09/ 19:21 * @Description */ public class Continue { public static void main(String[] args) { int i = 0; while (i &lt; 100){ i ++; if (i%10 == 0){ System.out.println(); continue; //每当遇到能被10整除的数时换行之后自动跳过本次循环，但是后续循环还会继续运行。 } System.out.print(i+\"\\t\"); } } } 输出结果：输出时遇到能被10整除的数自动跳过。 拓展：关于goto关键字 goto关键字很早就在程序设计中出现，但仍是Java的一个保留字，并未在语言中得到正式使用；Java没有goto，然而我们在break和continue这两个关键字上，可以看到goto的影子——带标签的break和continue 标签是指后面跟一个冒号的标识符，例如：label； 对Java来说唯一用到标签的地方是在循环语句之前，而在循环之前设置标签的唯一理由是：我们希望在其中嵌套另一个循环，由于break和continue关键字通常只中断当前循环，但若随同标签使用，他们就会中断到存在标签的地方。 联系设计一个程序打印出一个三角形。 ********** **** **** *** *** ** ** * * package com.xiheya.struct; /** * @Author {xiheya} * @Date: 2022/03/11/ 15:56 * @Description */ public class TestDemo01 { public static void main(String[] args) { for (int i = 1; i &lt;= 5; i++) { for (int j = 5; j >= i; j--) { System.out.print(\"*\"); } for (int k = 1; k &lt; i; k++) { System.out.print(\" \"); } for (int k = 5; k >= i; k--) { System.out.print(\"*\"); } System.out.println(); } } }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"},{"name":"Java流程控制","slug":"Java流程控制","permalink":"/tags/Java流程控制/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Java流程控制02","slug":"Java流程控制02","date":"2022-08-25T14:40:57.000Z","updated":"2022-08-25T15:03:50.824Z","comments":true,"path":"2022/08/25/javaliuchengkongzhi02/","link":"","permalink":"/2022/08/25/javaliuchengkongzhi02/","excerpt":"","text":"顺序结构 Java的基本结构就是顺序结构，除非特别指明，否则就按照顺序一句一句执行 顺序结构是最简单的算法结构 语句与语句之间，框与框之间是按从上到下的顺序进行的，他是由若干个依次执行的处理步骤组成的，他是一个任何算法都离不开的一种基本算法结构 代码： package com.xiheya.struct; /** * @Author {xiheya} * @Date: 2022/03/08/ 16:12 * @Description */ public class orderDemo01 { public static void main(String[] args) { System.out.println(\"helloworld1\"); System.out.println(\"helloworld2\"); System.out.println(\"helloworld3\"); System.out.println(\"helloworld4\"); } } 因为Java的基本结构是顺序结构，所以会依次输出helloworld1234 输出结果： 选择结构if单选择结构 很多时候需要判断一个东西是否可行，然后再去执行，这个时候我们就需要用到if语句 语法： if(布尔表达式){ //如果布尔表达式为true就执行这里面的语句 } 代码： package com.xiheya.struct; import java.util.Scanner; /** * @Author {xiheya} * @Date: 2022/03/08/ 16:17 * @Description */ public class ifDemo01 { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); String s = scanner.nextLine(); if (s.equals(\"helloworld\")){ System.out.println(\"helloworld\"); } System.out.println(\"End\"); scanner.close(); } } 因为是单判断语句，所以输出时会先判断输入的内容是否为helloworld，如果是的话就输出helloworld后输出End，如果不是就直接输出End 输出结果 if双选择结构语法和单选择结构类似 if(布尔表达式){ //如果布尔表达式为true就执行这里面的语句 }else{ //如果布尔表达式为false就执行这里面的语句 } 设计一个程序，输入分数大于60时输出及格，否则输出不及格 package com.xiheya.struct; import java.util.Scanner; /** * @Author {xiheya} * @Date: 2022/03/08/ 16:27 * @Description */ public class IfDemo02 { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.println(\"请输入成绩\"); if (scanner.nextInt() > 60){ System.out.println(\"您的成绩及格\"); } else{ System.out.println(\"您的成绩不及格\"); } scanner.close(); } } if多选择结构语法： if(布尔表达式 1){ //如果布尔表达式1为true就执行这里面的语句 }else if(布尔表达式 2){ //如果布尔表达式2为true就执行这里面的语句 }else if(布尔表达式 3){ //如果布尔表达式3为true就执行这里面的语句 }else{ //如果以上布尔表达式为false就执行这里面的语句 } 设计一个程序输入的分数为100时输出满分；90-100为A；80-90为B；70-80为C；60-70为D；小于60为不及格，其余成绩为不合法 代码： package com.xiheya.struct; import java.util.Scanner; /** * @Author {xiheya} * @Date: 2022/03/08/ 16:27 * @Description */ public class IfDemo03 { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.println(\"请输入成绩\"); int score = scanner.nextInt(); if (score == 100){ System.out.println(\"满分！\"); }else if(score &lt; 100 &amp;&amp; score >= 90){ System.out.println(\"A!\"); }else if(score &lt; 90 &amp;&amp; score >= 80){ System.out.println(\"B!\"); }else if(score &lt; 80 &amp;&amp; score >= 70){ System.out.println(\"C!\"); }else if(score &lt; 70 &amp;&amp; score >= 60){ System.out.println(\"D!\"); } else if(score &lt; 60 &amp;&amp; score >= 0){ System.out.println(\"您的成绩不及格\"); } else { System.out.println(\"成绩不合法\"); } scanner.close(); } } 嵌套的if结构 使用嵌套的if……else语句是合法的。也就是说你可以在另一个if或者else if语句中使用if或者else if语句，你可以像if语句一样嵌套else if……else 语法 if(布尔表达式1){ //如果布尔表达式为true就执行 if(布尔表达式2){ //如果布尔表达式2为true就执行 } } switch多选择结构 多选择结构还有一个实现方式就是switch case语句 switch case语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支 语法： switch(expression){ case value : //语句 break;//可选 case value : //语句 break;//可选 //你可以有任意数量的case语句 default : //可选 //语句 } switch 语句中的变量类型可以是 byte 、short、int或者char 从Java SE 7开始 switch就支持字符串String型了 同时case标签必须为字符串常量或字面量 设计一个程序，根据ABCD输出不同的评价。 代码： package com.xiheya.struct; /** * @Author {xiheya} * @Date: 2022/03/08/ 17:09 * @Description */ public class SwitchDemo01 { public static void main(String[] args) { char grade = 'G'; switch (grade){ case 'A' : System.out.println(\"优秀\"); break; case 'B' : System.out.println(\"良好\"); break; case 'C' : System.out.println(\"及格\"); break; case 'D' : System.out.println(\"再接再厉\"); break; case 'E' : System.out.println(\"挂科\"); break; default: System.out.println(\"未知成绩\"); } } } Java SE 7 新特性 代码 package com.xiheya.struct; /** * @Author {xiheya} * @Date: 2022/03/08/ 17:20 * @Description */ public class SwitchDemo02 { public static void main(String[] args) { String name = \"hahaha\"; switch (name){ case \"xiheya\": System.out.println(\"right\"); break; case \"hahaha\": System.out.println(\"error\"); break; default: System.out.println(\"???\"); } } }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"},{"name":"Java流程控制","slug":"Java流程控制","permalink":"/tags/Java流程控制/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Java流程控制01","slug":"Java流程控制01","date":"2022-08-25T14:38:42.000Z","updated":"2022-08-25T15:03:47.752Z","comments":true,"path":"2022/08/25/javaliuchengkongzhi01/","link":"","permalink":"/2022/08/25/javaliuchengkongzhi01/","excerpt":"","text":"用户交互Scanner Java给我们提供了一个工具类，我们可以根据这个工具类来获取用户的输入。java.util.Scanner是Java5的新特征，我们可以通过Scanner类来获取用户的输入 基本语法 Scanner s = new Scanner(System.in); 通过Scanner类的next()与nextLine()方法获取输入的字符串，在读取前我们一般需要使用hasNext()与hasNextLine()来判断是否还有输入的数据. 使用hasNext()方法判断是否还有输入的数据；next()方法接收输入的字符 package com.xiheya.Scanner; import java.util.Scanner; /** * @Author {xiheya} * @Date: 2022/03/07/ 23:32 * @Description */ public class Demo01 { public static void main(String[] args) { //声明一个Scanner类型的变量 Scanner scanner = new Scanner(System.in); //声明一个String类型的变量 //String str; //判断是否还有输入的数据 System.out.println(\"请从键盘上输入任意字符，以空格键或回车键结束\"); if (scanner.hasNext()){ String str = scanner.next(); System.out.println(\"从键盘上输入字符为：\" + str); } //用完一定要记得关闭！！！ scanner.close(); } } 使用hasNextLine()方法判断是否还有输入的数据；nextLine()方法接收输入的字符 package com.xiheya.Scanner; import java.util.Scanner; /** * @Author {xiheya} * @Date: 2022/03/07/ 23:32 * @Description */ public class Demo01 { public static void main(String[] args) { //声明一个Scanner类型的变量 Scanner scanner = new Scanner(System.in); //声明一个String类型的变量 //String str; //判断是否还有输入的数据 System.out.println(\"请从键盘上输入任意字符，以回车键结束\"); if (scanner.hasNextLine()){ String str = scanner.nextLine(); System.out.println(\"从键盘上输入字符为：\" + str); } //用完一定要记得关闭！！！ scanner.close(); } } 不判断是否还有输入的数据；直接nextLine()方法接收输入的字符 package com.xiheya.Scanner; import java.util.Scanner; /** * @Author {xiheya} * @Date: 2022/03/07/ 23:32 * @Description */ public class Demo01 { public static void main(String[] args) { //声明一个Scanner类型的变量 Scanner scanner = new Scanner(System.in); //声明一个String类型的变量 //String str; //判断是否还有输入的数据 System.out.println(\"请从键盘上输入任意字符，以回车键结束\"); String str = scanner.nextLine(); System.out.println(\"从键盘上输入字符为：\" + str); //用完一定要记得关闭！！！ scanner.close(); } } IO流的类用完一定要关掉，不然他会在后台一直占用资源!!!! next()与nextLine()方法的区别 Scanner是一个扫描器，我们录取到键盘的数据，先存到缓存区等待读取，它判断读取结束的标示是 空白符；比如空格，回车，tab 等等。 next()方法是读取到空白符就结束了 一定要读取到有效字符后才可以结束输入 对输入有效字符之前遇到的空白，next()方法会自动将其去掉。 只有输入有效字符后才将其后面输入的空白符作为分隔符或结束符 next()不能得到带有空格的字符串 nextLine()方法是读取到了回车就结束即：\\t. 以enter为结束符，也就是说nextLine()方法 返回的是输入回车之前的所有字符 可以获得空白符 Scanner中的其他方法 hasNextInt() 方法与 hasNextfloat()方法可以判断下一个是否还有整数或小数输入。 package com.xiheya.Scanner; import java.util.Scanner; /** * @Author {xiheya} * @Date: 2022/03/08/ 12:31 * @Description */ public class Demo02 { public static void main(String[] args) { int i = 0; float f = 0f; Scanner scanner = new Scanner(System.in); System.out.println(\"请从键盘上输入任意整数\"); if (scanner.hasNextInt()){ i = scanner.nextInt(); System.out.println(\"输入的整数为\" + i); } else { System.out.println(\"Error！您输入的不是整数\"); } System.out.println(\"请从键盘上输入任意小数\"); if (scanner.hasNextFloat()){ f = scanner.nextFloat(); System.out.println(\"输入的小数为\" + f); } else { System.out.println(\"Error！您输入的不是小数\"); } scanner.close(); } } hasNextdouble()方法：判断接下来输入的是不是double型； 学到这里可以做一个简易的数字求和程序，代码如下： package com.xiheya.Scanner; import java.util.Scanner; /** * @Author {xiheya} * @Date: 2022/03/08/ 12:52 * @Description */ public class Demo03 { public static void main(String[] args) { double total = 0; int m = 0; Scanner scanner = new Scanner(System.in); System.out.println(\"请从键盘上输入任意个数，以字符型数据结束\"); while (scanner.hasNextDouble()){ double x = scanner.nextDouble(); total = total + x; m++; System.out.println(\"您输入了\" + m + \"个数，和为：\" + total); } double v = total / m; System.out.println(\"您结束了输入，此次您输入了\" + m + \"个数，和为：\" + total + \"这些数的平均值为：\" + v); scanner.close(); } } 运行结果如下：","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"},{"name":"Java流程控制","slug":"Java流程控制","permalink":"/tags/Java流程控制/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Java基础语法04","slug":"Java基础语法04","date":"2022-08-25T14:37:45.000Z","updated":"2022-08-25T15:04:20.806Z","comments":true,"path":"2022/08/25/javajichuyufa04/","link":"","permalink":"/2022/08/25/javajichuyufa04/","excerpt":"","text":"包机制 为了更好地组织类，Java提供了包机制，用于区别类名的命名空间 包语句的语法格式为 package pkg1[.pkg2[.pkg3...]]; 一般利用公司域名倒置作为包名 为了能够使用某一个包的成员，我们需要在Java程序中明确导入该包。使用import语句可完成此项功能 import package1[.package2...].(classname|*); JavaDoc生成文档Win + r 后输入： javadoc -encoding UTF-8 -charset UTF-8 ***.java","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"},{"name":"Java基础语法","slug":"Java基础语法","permalink":"/tags/Java基础语法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Java基础语法03","slug":"Java基础语法03","date":"2022-08-25T14:37:23.000Z","updated":"2022-08-25T15:04:17.682Z","comments":true,"path":"2022/08/25/javajichuyufa03/","link":"","permalink":"/2022/08/25/javajichuyufa03/","excerpt":"","text":"运算符Java语言支持的与算符算术运算符符号算术运算符符号：+ , - , * , / , ++ , – package Operator; public class Demo01 { public static void main(String[] args) { //算数运算符的基本操作 int a = 10; int b = 20; int c = 30; int d = 40; System.out.println(a+b); System.out.println(a-b); System.out.println(a*b); System.out.println(a/(double)b); System.out.println(a%b); } } 小tips 当参与运算的变量中有long型时，输出的结果也为long型 若参与运算的变量中五long型时，无论参与运算的变量是何类型，则输出结果均为int型 eg： package Operator; public class Demo01 { public static void main(String[] args) { //算数运算符的基本操作 long a = 10; int b = 20; byte c = 30; short d = 40; System.out.println((String) (a+b)); System.out.println((String) (b+c)); System.out.println((String) (c+d)); System.out.println((String) (b+d)); } } 自增（++）、自减（–）运算符 package Operator; public class Demo03 { public static void main(String[] args) { //++ -- 自增 自减 一元运算符 int a = 1; int b = a++; //执行这行代码时，先进行赋值操作把a的初始值1赋值给b；然后a再执行自增操作a = a+1 = 2。 System.out.println(a); int c = ++a; //执行这行代码时，先进行a = 2自增操作a = a+1 =3；然后再执行赋值操作把a值3赋值给c。 System.out.println(a); System.out.println(b); System.out.println(c); } } 赋值运算符符号赋值运算符符号：= 语法格式//语法格式如下 int a = 10; //初始化int类型变量a，并将10赋值给a。 关系运算符符号：关系运算符符号：&gt; , &lt; , &gt;= , &lt;= , == , != , instanceof 关系运算符返回的是 布尔值，其结果只有true和false两种情况，常用于if语句中 语法格式package Operator; public class Demo02 { public static void main(String[] args) { //关系运算符返回的是 布尔值，其结果只有true和false两种情况，常用于if语句中 int a = 10 ; int b = 20 ; System.out.println(a == b); System.out.println(a != b); System.out.println(a &lt; b); System.out.println(a > b); } } 逻辑运算符符号逻辑运算符符号：&amp;&amp; , || , ! 语法格式package Operator; public class Demo04 { public static void main(String[] args) { boolean a = true; boolean b = false; System.out.println(\"a&amp;&amp;b:\\t\"+(a &amp;&amp; b)); //逻辑与运算：只要有一个是假的，则结果就是假的 System.out.println(\"a||b:\\t\"+(a || b)); //逻辑或运算：只要有一个是真的，则结果就是真的 System.out.println(\"!(a&amp;&amp;b):\\t\"+!(a &amp;&amp; b)); //逻辑非运算：结果取反 //短路运算：当与运算中第一个变量为假时，就不会再去判断第二个变量。 int c = 5; boolean d = b &amp;&amp; (c++ > 5); System.out.println(d); System.out.println(c); } } 位运算符符号位运算符符号：&amp; , | , ^ , ~ , &gt;&gt; , &lt;&lt; , &gt;&gt;&gt; 语法格式语法格式如下 package Operator; public class Demo05 { public static void main(String[] args) { /* A = 0010 1101 B = 1011 1001 ------------------- A&amp;B = 0010 1001 A|B = 1011 1101 A^B = 1001 0100 异或运算：变量真假相同时结果为假，不同时为真 ~B = 0100 0110 */ //快速计算2*8 System.out.println(2&lt;&lt;3); } } 条件运算符符号条件运算符符号：x ? y : z : 语法格式语法格式如下： package Operator; public class Demo05 { public static void main(String[] args) { int a = 10; int b = 20; // 条件运算符 x ? y : z // 先判断x是否为真，若x为真，则结果是y；若x为假，则结果是z System.out.println((a>b) ? 50 : 60); System.out.println((a&lt;b) ? 50 : 60); } } 扩展赋值运算符符号扩展赋值运算符符号：+= , -= , *= , /= 语法格式语法格式如下 package Operator; public class Demo05 { public static void main(String[] args) { int a = 10; int b = 20; a+=b; System.out.println(a); // a = a+b -->30 = 10+20 a-=b; System.out.println(a); // a = a-b -->10 = 30-20 //字符串连接符 + //当+号两侧的任意一侧出现了String类型，则它会自动将两侧的变量都转换为String类型并进行连接。 System.out.println(\"\" + a + b); //但是如果String类型前面出现了运算，则会先运算再连接。 System.out.println(b+ a + \"\" ); } } 运算符优先级 优先级 运算符 简介 结合性 1 [ ]、.、( ) 方法调用，属性获取 从左向右 2 !、~、 ++、 – 一元运算符 从右向左 3 * 、/ 、% 乘、除、取模（余数） 从左向右 4 + 、 - 加减法 从左向右 5 &lt;&lt;、 &gt;&gt;、 &gt;&gt;&gt; 左位移、右位移、无符号右移 从左向右 6 &lt; 、&lt;= 、&gt;、 &gt;=、 instanceof 小于、小于等于、大于、大于等于， 对象类型判断是否属于同类型 从左向右 7 == 、!= 2个值是否相等，2个值是否不等于。 下面有详细的解释 从左向右 8 &amp; 按位与 从左向右 9 ^ 按位异或 从左向右 10 \\ 按位或 从左向右 11 &amp;&amp; 短路与 从左向右 12 \\ \\ 短路或 从左向右 13 ?: 条件运算符 从右向左 14 =、 += 、-= 、*= 、/=、 %=、 &amp;=、 \\ =、 ^=、 &lt;、&lt;= 、&gt;、&gt;= 、&gt;&gt;= 混合赋值运算符 从右向左 点击查看Java基础语法之注释、标识符、数据类型（一） 点击查看Java基础语法之类型转换和变量（二）","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"},{"name":"Java基础语法","slug":"Java基础语法","permalink":"/tags/Java基础语法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Java基础语法02","slug":"Java基础语法02","date":"2022-08-25T14:36:16.000Z","updated":"2022-08-25T15:04:14.634Z","comments":true,"path":"2022/08/25/javajichuyufa02/","link":"","permalink":"/2022/08/25/javajichuyufa02/","excerpt":"","text":"类型转换 由于Java是强类型语言，所以要进行有些运算的时候，需要用到类型转换 //低----------------------------------------->高 byte,short,char ---> int ---> long ---> double; //小数的优先级一定大于整数 运算中，不同类型的数据先转换为同一类型，然后再进行运算 强制类型转换: (类型)变量名; 高—&gt;低 自动类型转换: 低—&gt;高 注意点： 不能对布尔值进行转换 不能打对象类型转换为不相干的类型 把高容量类型转换到低容量类型时，需要强制转换* 2.转换可能会出现内存溢出或精度问题 public class Demo03 { public static void main(String[] args) { int i = 128 ; byte b = (byte) i; //内存溢出 //强制转换 (类型)变量名; 高--->低 //自动转换 低--->高 System.out.println(i); System.out.println(b); System.out.println(\"=========================\"); /* * 注意点： * 1.不能对布尔值进行转换 * 2.不能打对象类型转换为不相干的类型 * 3.把高容量类型转换到低容量类型时，需要强制转换 * 4.转换可能会出现内存溢出或精度问题 * */ System.out.println((int) 30.7); System.out.println((int) 43.33f); System.out.println(\"=========================\"); char c = 'a'; int d = c + 1; System.out.println(d); System.out.println((char) d); } } 变量 变量：即为可以变化的量 Java是一种强类型语言，每个变量都必须声明其类型。 Java变量时程序中最基本的存储单元，其要素包括变量名，变量类型和作用域 type varName [=value][{,varName[=value]}]; //数据类型 变量名 = 值；可以用逗号隔开来声明多个同类型变量 int a,b,c = 10; 注意事项 每个变量都有类型，类型可以是基本类型，也可以是引用类型 变量名必须是合法的标识符 变量声明是一条完整的语句，因此每一个声明都必须以分号结束。 变量的命名规范 所有变量、方法、类名：见名知意 类成员变量：首字母小写和驼峰原则：monthSalary 局部变量：首字母小写和驼峰规则 常量：大写字母和下划线：MAX_VALUE 类名：首字母大写和驼峰原则：Man、GoodMan 方法名：首字母小写和驼峰原则：run(),runRun();","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"},{"name":"Java基础语法","slug":"Java基础语法","permalink":"/tags/Java基础语法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Java基础语法01","slug":"Java基础语法01","date":"2022-08-25T14:34:29.000Z","updated":"2022-08-25T15:04:09.409Z","comments":true,"path":"2022/08/25/javajichuyufa01/","link":"","permalink":"/2022/08/25/javajichuyufa01/","excerpt":"","text":"注释 平时编写代码时，在代码量较少的时候。代码的可读性更强，但是当项目结构一旦复杂起来，我们就需要注释。 注释不会被执行，只是给我们写代码的人看的 书写注释是一个非常好的编程习惯 Java中的注释 单行注释 // public class HelloWorld { public static void main(String[] args) { //我是单行注释 System.out.println(\"HelloWorld!\"); } } 多行注释/**/ public class HelloWorld { public static void main(String[] args) { /*我是多行注释 我是多行注释 */ System.out.println(\"HelloWorld!\"); } } 文档注释/* / public class HelloWorld { public static void main(String[] args) { /* *我是文档注释 我是文档注释 */ System.out.println(\"HelloWorld!\"); } } Java标识符关键字 Java所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符 标识符注意点 所有标识符都应该以字母（A-Z或者a-z），美元（￥）或者下划线（_）开始 首字符过后可以是字母（A-Z或者a-z）、美元（￥）、下划线（_）或者数字的任何字符组合 不能使用关键字作为变量名或方法名 标识符是大小写敏感的 不建议使用中文或者拼音作为变量名或方法名 Java数据类型 强类型语言 要求变量的使用必须要严格符合规定，所有变量都必须先定义后才能使用 Java数据类型分为两大类 基本类型(primitive type) 引用类型(reference type) 基本类型 No. 数据类型 大小/位 可表示数据范围 默认值 1 byte（字节型） 8 -128~127 0 2 short（短整型） 16 -32768~32767 0 3 int（整型） 32 -2147483648~2147483647 0 4 long（长整型） 64 -9223372036854775808~9223372036854775807 0 5 float（单精度） 32 -3.4E38~3.4E38 0.0 6 double（双精度） 64 -1.7E308~1.7E308 0.0 7 char（字符） 16 0~255 ‘\\u0000’ 8 boolean（布尔） - true或false false 引用类型 引用数据类型非常多，大致包括：类、 接口类型、 数组类型、 枚举类型、 注解类型、 字符串型 如String为引用类型 public class Demo01 { public static void main(String[] args) { //整型：int(4字节)、byte(1字节)、short(2字节)还有long(8字节) int num01 = 10; byte num02 = 20; short num03 = 30; long num04 = 40l; //浮点型：float(4字节)、double(8字节) float num05 = 50.66f; double num06 = 66.66; //字符：char(2字节) char usr = 'x'; //布尔值：boolean boolean flag = true; } } 小科普 位(bit):是计算机内部数据存储的最小单位，10100101是一个八位二进制数 字节(Byte): 是计算机中数据处理的基本单位，习惯上用大写的B来表示 1B(Byte,字节) = 8bit(位) 字符:是指计算机中使用的字母、数字、字和符号 1bit = 1位; 1Byte = 1B = 8b; 1024B = 1KB 1024KB = 1M 1024M = 1G Java数据类型拓展 整数拓展， 0b表示二进制数、0表示八进制、十进制直接输入、0x表示十六进制 import java.math.BigDecimal; public class Demo02 { public static void main(String[] args) { //整数拓展， 0b表示二进制数、0表示八进制、十进制直接输入、0x表示十六进制 int b = 0b10; int i = 10; int i1 = 010; int i2 = 0x10; System.out.println(b); System.out.println(i); System.out.println(i1); System.out.println(i2); System.out.println(\"===================================\"); } } 浮点数扩展 银行业务表示， 常使用数学工具类BigDecimal，来表示银行业务。float数据类型是有限的，而且是离散的。它会舍入误差只表示一个大概的数，—–&gt;接近但不等于！最好避免完全使用浮点数进行比较！！！ a public class Demo02 { public static void main(String[] args) { //浮点数扩展 银行业务表示， //通常使用数学工具类BigDecimal，来表示银行业务。 System.out.println(\"===================================\"); //float float数据类型是有限的，而且是离散的。它会舍入误差只表示一个大概的数，----->接近但不等于 //double //最好避免完全使用浮点数进行比较 //最好避免完全使用浮点数进行比较 //最好避免完全使用浮点数进行比较 float f = 0.1f; double d = 1.0/10; System.out.println(f == d); System.out.println(\"===================================\"); float f1 = 12345667486234f; float f2 = f1 + 1; System.out.println(f1 == f2); System.out.println(\"===================================\"); } } 字符扩展 System.out.println((int)c1); //将char型的c1 强制转换为int型的Unicode编码 所有字符的本质还是数字，他们存放在一个Unicode编码表内（97 = a 、 65 = A） ，他占两个字节； 转义字符： \\t 制表符、 \\n 换行符…… a import java.math.BigDecimal; public class Demo02 { public static void main(String[] args) { //字符扩展 System.out.println(\"===================================\"); char c1 = 'a'; char c2 = '荣'; System.out.println(c1); System.out.println((int)c1); //将char型的c1 强制转换为int型的Unicode编码 System.out.println(c2); System.out.println((int)c2); //将char型的c2 强制转换为int型的Unicode编码 System.out.println(\"===================================\"); char c3 = '\\u0066'; //将Unicode编码0066转义为char型数据c3 System.out.println(c3); //所有字符的本质还是数字，他们存放在一个Unicode编码表内（97 = a 、 65 = A） ，他占两个字节； //转义字符 \\t 制表符、 \\n 换行符…… System.out.println(\"Hello\\t World!\"); } } 布尔值扩展： less is more 代码要精简易读； import java.math.BigDecimal; public class Demo02 { public static void main(String[] args) { //布尔值扩展 boolean flag = true; if (flat == true){}; if (flag){}; //less is more 代码要精简易读； } }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"},{"name":"Java基础语法","slug":"Java基础语法","permalink":"/tags/Java基础语法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Markdown基本语法","slug":"Markdown基本语法","date":"2022-08-25T14:33:19.000Z","updated":"2022-08-25T15:01:01.864Z","comments":true,"path":"2022/08/25/markdownjibenyufa/","link":"","permalink":"/2022/08/25/markdownjibenyufa/","excerpt":"","text":"Markdown 基本语法一.标 题: 1.1 一级标题 #+空格+文本+回车 1.2 二级标题 ##+空格+文本+回车 1.3 三级标题 ###+空格+文本+回车 .....以此类推 二.字体粗体：文本两边加** eg: **Hello World** Hello World 斜体：文本两边加* eg: *Hello World* Hello World 粗体加斜体：文本两边加*** eg: ***Hello World*** Hello World 中间横线：文本两边加~~ eg: ~~Hello World~~ Hello World 三.引用右箭头后面接上文本> eg: >与君共赴，万里征程。 与君共赴，万里征程。 四.分割线三个-（减号）表示分割线 eg: --- 三个*（减号）表示分割线 eg: *** 五.图片插入图片：!+[图片名字]+(图片路径) eg:![示例1](https://images.unsplash.com/photo-1646408271568-977e12b6425a?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1170&q=80) 六. 超链接语法：[标题](链接地址) eg:[Idea快捷键](http://110.42.139.30:8000/index.php/2022/03/06/13/) idea快捷键 七. 列表有序列表语法：1 + . + 空格 A B C 无序列表语法： - + 空格 A B C 八.表格语法： | 名字 | 性别 | 生日 | | ---- | ---- | -------- | | 张三 | 男 | 2000.1.1 | 名字 性别 生日 张三 男 2000.1.1 九.代码语法 ``` + 编程语言名称 eg ```shell public 十.快捷键文本编辑快捷键 无序列表：输入-之后输入空格 / ctrl + shift + ] (对选中行可用) 有序列表：输入数字 + “.”之后输入空格 / ctrl + shift + [ (对选中行可用) 引用内容：&gt; + 空格 / ctrl + shift + q (对选中内容可用) 任务列表：-[空格]空格 文字 标题：ctrl + 数字 表格：ctrl + t 目录：[TOC] 任务列表：- [ ] 文字（注意 “-” 后与 “[]“ 中间都有空格） 选中一整行：ctrl + l (字母L) 选中单词：ctrl + d 选中相同格式的文字：ctrl + e 跳转到文章开头：ctrl + home 跳转到文章结尾：ctrl + end 搜索：ctrl + f 替换：ctrl + h 引用：输入&gt;之后输入空格 代码块： ctrl + shift + k 行内代码：ctrl + shift + ` (对选中行可用) 加粗：ctrl + b 倾斜：ctrl + i 下划线：ctrl + u 删除线：alt + shift + 5 插入链接：ctrl + k 插入公式：ctrl + shift + m 插入图片：ctrl + shift + i 保存：ctrl + s 另存为：ctrl + shift + s 编辑模式快捷键 源码模式编辑切换：ctrl + / 打字机模式切换：F9 专注模式切换：F8 全屏模式切换：F11 Typora内部窗口焦点切换：ctrl + tab 侧边栏显示/隐藏切换：ctrl + shift + L","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"/tags/Markdown/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Java运行机制及IDEA安装教程","slug":"Java运行机制及IDEA安装教程","date":"2022-08-25T14:32:04.000Z","updated":"2022-08-25T15:01:24.754Z","comments":true,"path":"2022/08/25/javayunxingjizhijiideaanzhuangjiaocheng/","link":"","permalink":"/2022/08/25/javayunxingjizhijiideaanzhuangjiaocheng/","excerpt":"","text":"Java运行机制及IDEA安装教程Hello World 新建一个Java文件 文件后缀名为.java Hello.java 编写代码 public class Hello{ public static void main(String[] args){ System.out.print(\"hello world\"); } } 编译java文件 cmd：javac Hello.java。会生成一个class文件 运行class文件 cmd：java Hello 可能会遇到的问题 Java是大小写敏感的语言，每个单词的大小写不能出现问题 尽量使用中文 文件名与类名必须保持一致 Java运行机制 编译型：先整个程序通过编译器先编译完成后再运行(操作系统、c/c++) 解释型：执行什么就读取什么(网页、Javascript) Java程序运行机制 IDEA安装教程1. 打开jetbrains官网下载IDEA 下载地址：https://www.jetbrains.com/zh-cn/idea/download/#section=windows 点击此处进入IDEA下载界面 2. 打开安装包之后，无脑next。 3. 安装目录不建议放在C盘 创建一个Java程序 双击打开IDEA快捷方式，首先new一个Project 然后选择Java语言导入JDK环境 鼠标右击src文件夹 new一个 java class 编写hello world public class Hello{ public static void main(String[] args){ System.out.print(\"hello world\"); } }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Java的特性与优势","slug":"Java的特性与优势","date":"2022-08-25T14:30:29.000Z","updated":"2022-08-25T15:04:42.468Z","comments":true,"path":"2022/08/25/javadetexingyuyoushi/","link":"","permalink":"/2022/08/25/javadetexingyuyoushi/","excerpt":"","text":"Java的特性和优势Java特性 简单性 面向对象 可移植性 高性能 分布式 动态性 多线程 安全性 健壮性 Java三大版本 JavaSE ： 标准版（桌面程序，控制台开发…… JavaME： 嵌入式开发（手机、小家电） JavaEE： 企业级开发（web端，服务器开发） JDK、JRE、JVM JDK： Java Development Kit JRE： Java Runtime Environment JVM： Java Virtual Machine Java开发环境安装卸载JDK 删除Java安装目录 删除环境变量中的JAVA_HOME 删除环境变量中的Path下关于Java的目录 安装JDK 打开官网找到电脑对应的版本，并下载到本地。JDk下载页面 双击安装包进行安装 记住安装的路径 配置环境变量 我的电脑—&gt; 右键 —&gt; 属性 高级系统设置 —&gt; 环境变量 —&gt; 新建系统变量 配置变量名： JAVA_HOME 值：Java的安装目录 配置Path：鼠标右击Path— 值为%JAVA_HOME%/lib 检查JDK是否安装成功 Win + r ：cmd 输入java -version 若打印出Java版本信息，则安装成功。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"},{"name":"Java特性","slug":"Java特性","permalink":"/tags/Java特性/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"常见dos命令","slug":"常见dos命令","date":"2022-08-25T14:29:04.000Z","updated":"2022-08-25T15:06:43.872Z","comments":true,"path":"2022/08/25/changjiandosmingling/","link":"","permalink":"/2022/08/25/changjiandosmingling/","excerpt":"","text":"基本Dos命令及计算机发展史一、打开cmd窗口方式 开始 + 系统+命令提示符 Win键+R 输入cmd打开控制台 在任意的文件夹下面，按住Shift键 + 鼠标右击，在此窗口打开命令行窗口 资源管理器的地址栏前面加上cmd路径 管理员身份运行，选择以管理员身份运行 二、常用的Dos命令#盘符切换 D: C: E: #进入任意目录 cd change directory #跨盘： cd /d E:\\data\\usr\\root #不跨盘 cd data #返回上一级目录 cd .. #查看当前目录下所有文件 dir ll ls #清理屏幕 cls clear screen cls #退出终端 exit eixt #查看IP ipconfig ipconfig #打开应用 calc 计算器；mspaint 画图软件； notepad 记事本 calc mspaint notepad #文件操作 #创建目录 md make directory md test #创建文件 cd>test.txt #删除文件 del test.txt #移除目录 rd remove directory rd test 计算机语言发展史一、第一代语言 机器语言 计算机的基本计算方式都是基于二进制的方式 二进制：01010110100100101 这种代码是直接输入给计算机使用的，不经过任何转换 二、第二代语言 汇编语言 解决人类无法读懂机器语言的问题 指令代替二进制 目前应用 逆向工程 机器人 病毒 … 三、第三代语言 摩尔定律 当价格不变时，集成电路上可容纳的集体管数目，约每隔18个月便会增加一倍，性能也会提升一倍。换言之，每一美元所能买到的电脑性能，将每隔18个月翻两倍以上 高级语言 大体上分为：面向过程和面向对象两大类 c语言是经典的面向过程的语言，c++和Java是典型的面向对象的语言","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"/tags/随笔/"},{"name":"Dos","slug":"Dos","permalink":"/tags/Dos/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"计算机硬件知识","slug":"计算机硬件知识","date":"2022-08-24T14:36:40.000Z","updated":"2022-08-25T15:06:07.163Z","comments":true,"path":"2022/08/24/jisuanjiyingjianzhishi/","link":"","permalink":"/2022/08/24/jisuanjiyingjianzhishi/","excerpt":"","text":"计算机硬件冯诺依曼体系结构 冯诺依曼体系结构是现代计算机的基础 输入数据和程序的输入设备 记忆程序和数据的存储器 完成数据加工处理的运算器 控制程序执行的控制器 输出处理结果的输出设备 一、中央处理器（CPU）是计算机的大脑，从内存中获取指令，然后执行这些指令。 CPU 包括 控制单元：用于控制和协调其他组件 算术逻辑单元：用于完成数值运算 每台计算机都有一个内部时钟，该时钟以固定速度发射电子脉冲。时钟速度越快，在给定时间段内执行的越多。速度单位：赫兹（Hz） 1 Hz相当于一个脉冲。1KHz = 1024Hz；1MHz = 1024 KHz； 二、存储设备 内存中的信息在断电时会丢失，可以考虑将程序与数据永久的保存在存储设备上。 存储设备主要有： 磁盘驱动器 -&gt;硬盘 光盘驱动器 -&gt;CD和DVD USB闪存驱动器 -&gt;U盘 三、内存 比特（bit）和字节（byte） 一个 0 或一个 1 存储为一个比特（ bit）也叫位，是计算机中最小存储单位。 计算机中最基本的存储单位是字节（byte） ​ 1Byte = 8 bit； ​ 1KB = 1024B； 1MB = 1024 KB； ​ 1GB = 1024MB； 1TB = 1024GB 一个程序和他的数据在被CPU执行前，必须移到计算机的内存中。 内存读取速度比硬盘读取速度快好多好多，而CPU的读取速度比内存又要快好多好多 计算机输入输出设备 输入设备：鼠标 键盘 输出设备：显示器和打印机 计算机两大鼻鼻祖 阿兰图灵：计算机科学之父和人工智能之父 冯诺依曼：计算机之父和博弈论之父 操作系统 操作系统是运行在计算机上的重要程序，它可以管理系统控制计算机的活动。 硬件、操作系统、应用程序控制计算机的活动。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"硬件","slug":"硬件","permalink":"/tags/硬件/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura","date":"2022-08-22T14:16:01.000Z","updated":"2022-08-23T15:15:15.777Z","comments":true,"path":"2022/08/22/hexothemesakura/","link":"","permalink":"/2022/08/22/hexothemesakura/","excerpt":"","text":"hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我？: {path: /about/, fa: fa-meetup}, 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: {path: /lab/, fa: fa-cogs }, } } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png} - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg} - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg} # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: {url: http://github.com/honjun, img: /img/social/github.png} sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png} wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png} zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png} email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg} wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png} # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: {url: http://github.com/honjun, fa: fa-github, color: 333} weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} qq: {url: https://wpa.qq.com/msgrd?v=3&uin=954655431&site=qq&menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 < (￣︶￣)> items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]}]}